{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://mikasa.github.io"},"pages":[{"title":"","date":"2016-11-25T05:48:09.225Z","updated":"2016-11-24T07:16:13.775Z","comments":true,"path":"404.html","permalink":"http://mikasa.github.io/404.html","excerpt":"","text":""},{"title":"Categories","date":"2016-11-25T05:48:08.507Z","updated":"2016-11-24T07:16:14.571Z","comments":true,"path":"categories/index.html","permalink":"http://mikasa.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-11-25T05:48:08.554Z","updated":"2016-11-24T07:16:14.836Z","comments":true,"path":"tags/index.html","permalink":"http://mikasa.github.io/tags/index.html","excerpt":"","text":""},{"title":"guestbook","date":"2015-10-14T06:06:17.000Z","updated":"2016-11-24T07:16:14.586Z","comments":true,"path":"guestbook/index.html","permalink":"http://mikasa.github.io/guestbook/index.html","excerpt":"","text":"念念不忘，必有回响 最近访客"},{"title":"about","date":"2015-10-14T01:23:39.000Z","updated":"2016-11-24T07:16:14.555Z","comments":true,"path":"about/index.html","permalink":"http://mikasa.github.io/about/index.html","excerpt":"","text":"Information1234567891011&#123; \"nickname\": \"/JetMuffin/\", \"locality\": \"Nanjing\", \"school\": \"NJU\", \"skills\": [\"Cloud Computing\", \"Web Development\", \"Algorithm\",], \"tags\": [\"Geek?\", \"ACMer\"], \"contact\": &#123; \"email\": [\"jeffchen328@gmail.com\", \"564936642@qq.com\"] \"weibo\": \"@JetMmmmmmuffin \", &#125;,&#125; Links GitHub WeiBo NJU ICS NAP Group 欢迎留言！ 最近访客"},{"title":"wiki","date":"2015-11-29T13:31:12.000Z","updated":"2016-11-24T07:16:15.554Z","comments":true,"path":"wiki/index.html","permalink":"http://mikasa.github.io/wiki/index.html","excerpt":"","text":"My PlanningLast Updated: 2016-01-12 11:03:20 持续更新中~ AlgorithmACM 图论 网络流 2-SAT 计算几何 凸包 数据结构 单调队列 splay TechniqueMesos Mesos调度算法（DRF): Mesos 调度机制及调度算法初探 (Updated on 2015/11/23) Mesos modules(Extending Mesos) Mesos Custom Resources Mesos Networking Mesos Authentication: Mesos Authentication详解 (Updated on 2015/12/28) Monitoring Frameworks mesos-hydra RENDLER marathon chronos Hadoop MapReduce MapReduce for Log Analysis Hadoop Streaming Hadoop Yarn Scheduler Executor Spark Spark RDD Spark GraphX Spark MLib Spark Applicatiions MPI MPI入门 Redis Redis操作总结 Zookeeper Zookeeper架构 Zookeeper master选举 ProjectsSearch Engine（信息检索课程结课项目） Distributed Web-Crawler(Crawler+Redis+Mongo) PageRank(by MapReduce or graphX) Reverse Index(by MapReduce) HHU-ACM-OnlineJudge 开源OJ选择及重构方案 Picloud 增量需求整理(before 2016/01/01) 业务逻辑代码重构(before 2016/02/01) Pieditor online operations(scale | crop | watermasks | filters) persistent volume HbaseORM(Contributed by Sloriac)"}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2016-11-25T03:33:34.697Z","updated":"2016-11-25T03:33:34.697Z","comments":true,"path":"2016/11/25/hello-world/","link":"","permalink":"http://mikasa.github.io/2016/11/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"使用 gh-md-doc 生成 markdown 文章结构","slug":"浣跨敤-gh-md-doc-鐢熸垚-markdown-鏂囩珷缁撴瀯","date":"2016-09-13T12:23:11.000Z","updated":"2016-11-24T07:16:14.321Z","comments":true,"path":"2016/09/13/浣跨敤-gh-md-doc-鐢熸垚-markdown-鏂囩珷缁撴瀯/","link":"","permalink":"http://mikasa.github.io/2016/09/13/浣跨敤-gh-md-doc-鐢熸垚-markdown-鏂囩珷缁撴瀯/","excerpt":"本篇技巧来自于我在 iQiyi 的云平台部门实习时的内部分享，主要用于文档编写。在开发开源项目或进行团队协作时，总要写一些文档，并把代码托管在 git 上，对于长篇文档希望能够生成文档的结构，这里就用到了一个非常好的插件 gh-md-toc。","text":"本篇技巧来自于我在 iQiyi 的云平台部门实习时的内部分享，主要用于文档编写。在开发开源项目或进行团队协作时，总要写一些文档，并把代码托管在 git 上，对于长篇文档希望能够生成文档的结构，这里就用到了一个非常好的插件 gh-md-toc。 生成 markdown table of contents 常常项目开发的文档都是用 markdown 格式编写，并且以代码的形式托管在 Git 上，同时，那么就可以使用 gh-md-toc来生成文档目录。 但是，gh-md-toc 会直接将结果打印到 stout，而我们想要的最好的效果是直接将其添加到文档头部，而不是从 stdout 再复制粘贴，然后还要格式化空行。 以本文档为例，gh-md-toc 生成的 table of contents 如下： 1234567Table of Contents================= * [生成 markdown table of contents](#生成-markdown-table-of-contents) * [使用 gh-md-toc 的奇技淫巧](#使用-gh-md-toc-的奇技淫巧)Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc) 显然，我们需要将这段文字添加到文件的头部，并且删除第一行空行，在最后一行添加一行空行。 使用 gh-md-toc 的奇技淫巧OK，Let’s Rock! 先看一条命令： 1$ gh-md-toc file.md | (tail -n +2 &amp;&amp; echo &quot;&quot; &amp;&amp; cat file.md) | sponge file.md 你会惊讶的发现，这条命令就完成了所有事，为 file.md 生成了 table ofcontents，并且自动添加在了 file.md 的头部，并且完美的处理了空行。 这里使用了一个好工具 sponge，想想为什么不能直接重定向到 file.md 呢？ 但是，追求极致的程序员不会止步，因为上面的命令中 file.md 这个待处理的文件出现了3 次，所以也挺烦人的，对吧，即使使用命令替换也来得不如一次直接。 OK，Let’s Rock Again! 添加一个函数，重定义 gh-md-toc，添加下面的函数定义到你的 shell rc，例如： bash，~/.bashrc zsh，~/.zshrc 1234567function gh-md-toc() &#123; if [ -z \"$1\" ]; then echo \"gh-md-toc &lt;markdown file&gt;\" return 1 fi /home/chengwei/Github/github-markdown-toc/gh-md-toc $1 | (tail -n +2 &amp;&amp; echo \"\" &amp;&amp; cat $1) | sponge $1&#125; 将上面的 /home/chengwei/Github/github-markdown-toc/gh-md-toc 替换成 gh-md-doc在你的系统上的路径。 注意：如果你把 gh-md-doc 放在了 $PATH 中，必须用绝对路径调用，否则就无限递归了 :-) 最后，source shell rc 配置文件，生效 123$ source ~/.bashrcOR$ source ~/.zshrc 现在，要为某个 markdown 文件添加 table of contents 只需要执行： 1$ gh-md-toc file.md","categories":[{"name":"设计开发","slug":"设计开发","permalink":"http://mikasa.github.io/categories/设计开发/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://mikasa.github.io/tags/markdown/"},{"name":"gh-md-doc","slug":"gh-md-doc","permalink":"http://mikasa.github.io/tags/gh-md-doc/"}],"keywords":[{"name":"设计开发","slug":"设计开发","permalink":"http://mikasa.github.io/categories/设计开发/"}]},{"title":"Moore vote algorithm 多数投票算法","slug":"Moore-vote-algorithm-澶氭暟鎶曠エ绠楁硶","date":"2016-09-04T12:24:16.000Z","updated":"2016-11-24T07:16:14.118Z","comments":true,"path":"2016/09/04/Moore-vote-algorithm-澶氭暟鎶曠エ绠楁硶/","link":"","permalink":"http://mikasa.github.io/2016/09/04/Moore-vote-algorithm-澶氭暟鎶曠エ绠楁硶/","excerpt":"在刷 leetcode 时，发现一道题目 Majority Element，要求求出数组中出现元素超过 n/2 的元素。思考了许久也只能写出 O(nlogn) 的解法（即用 map 计数）。查阅资料后发现一个比较巧妙的算法 Moore vote algorithm，可以在 O(n) 时间和 O(1) 空间解决这个问题。","text":"在刷 leetcode 时，发现一道题目 Majority Element，要求求出数组中出现元素超过 n/2 的元素。思考了许久也只能写出 O(nlogn) 的解法（即用 map 计数）。查阅资料后发现一个比较巧妙的算法 Moore vote algorithm，可以在 O(n) 时间和 O(1) 空间解决这个问题。 算法思想算法的思想很简单，每次从数组中取一对数，如果相同就叠加，如果不同就一起删去，很明显最后留下的肯定是数量最多的一个数。再深入一步实现，只要用一个变量记录标记元素和标记元素的出现次数，然后找下一个元素，分以下情况： 如果下一个元素和标记元素相同，那么标记元素出现次数加1； 如果和标记元素不同，那么标记元素出现次数减1； 如果标记元素变为 0，那么取下一个元素作为标记元素，初始出现次数为1； 举个说明性的例子，数列 [2,3,2,2,4,1,2]，标记元素变量 now，出现次数 count 初始状态（取第一个数）：now:2，count:1 取第二个数 3，它和 now 不同，那么 count--，这时候 count = 0，那么拿下一个元素（第三个数）为标记元素 now:2，count:1 取第四个数 2，它和 now 相同，那么 count++，状态变为 now:2，count:2 取第五个数 4，它和 now 不同，那么 count--，状态变为 now:2，count:1 重复以上过程直到结尾，最后 now:2，所以数量超过 n/2 的元素为 2 算法实现为了更好实现上述过程，事实上程序的伪代码为： 123456789For i from 0 to len(arr): if count == 0: now = arr[i] count = 1 else: if now == arr[i]: count ++ else: count -- 即只要标记元素被删去了，那么访问的下一个元素就作为标记元素。 代码实现12345678910111213141516171819class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int count = 0, now = 0; for(int i = 0 ; i &lt; nums.size(); i++) &#123; if(count == 0) &#123; now = nums[i]; count = 1; &#125; else &#123; if(now == nums[i]) &#123; count ++; &#125; else &#123; count --; &#125; &#125; &#125; return now; &#125;&#125;; 参考资料 算法效果演示","categories":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}],"tags":[{"name":"moore vote algorithm","slug":"moore-vote-algorithm","permalink":"http://mikasa.github.io/tags/moore-vote-algorithm/"}],"keywords":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}]},{"title":"Zabbix配合lm_sensors监控服务器CPU温度","slug":"Zabbix閰嶅悎lm-sensors鐩戞帶鏈嶅姟鍣–PU娓╁害","date":"2016-09-01T06:18:06.000Z","updated":"2016-11-24T07:16:14.150Z","comments":true,"path":"2016/09/01/Zabbix閰嶅悎lm-sensors鐩戞帶鏈嶅姟鍣–PU娓╁害/","link":"","permalink":"http://mikasa.github.io/2016/09/01/Zabbix閰嶅悎lm-sensors鐩戞帶鏈嶅姟鍣–PU娓╁害/","excerpt":"手上的一个任务，需要对集群的每台机器 CPU 温度进行监控，防止集群在进行计算时温度过高导致 CPU 损坏。由于集群里已经部署了 Zabbix 进行监控和报警，所以很自然的想法就是在 Zabbix 中集成 CPU 监控这一内容。 首先是获取 CPU 温度的方法，常见的有两种： IPMI lm_sensors 其中 IPMI 需要硬件上的支持，同时还需要进行配置，比较复杂。而 lm_sensors 是 linux 下的一个小工具，安装简单，所以这里就选择 lm_sensors 来采集 CPU 的温度。","text":"手上的一个任务，需要对集群的每台机器 CPU 温度进行监控，防止集群在进行计算时温度过高导致 CPU 损坏。由于集群里已经部署了 Zabbix 进行监控和报警，所以很自然的想法就是在 Zabbix 中集成 CPU 监控这一内容。 首先是获取 CPU 温度的方法，常见的有两种： IPMI lm_sensors 其中 IPMI 需要硬件上的支持，同时还需要进行配置，比较复杂。而 lm_sensors 是 linux 下的一个小工具，安装简单，所以这里就选择 lm_sensors 来采集 CPU 的温度。 安装lm_sensors 的安装很简单，repo 里已经有这个包了，所以直接通过 yum 安装就行了（集群是用的 CentOS，Debian系的也差不多）。 1$ yum install lm_sensors 考虑到大多数集群是无法直接通外网的，所以可以在一台可以通外网的机器上下好 rpm 包，再传到 NFS 上或者直接 scp进去。下载 rpm 包可以使用 yumdownloader，刚好 lm_sensors 没有要依赖的包。 1$ yumdownloader install lm_sensors 采集采集数据之前，先看一下 zabbix 的自定义监控项的定义方法。在 zabbix_agentd 中对自定义监控项的定义格式为： 1UserParameter=&lt;key&gt;,&lt;shell command&gt; 其中可以看出监控项通过一句 shell 命令获得，并且获得的需要是一个数值。这样我们大概明确了需要采集的目标。 然后先简单过掉下 lm_sensors 需要的配置，即监测 sensors 的信息。 12345678$ sensors-detectThis program will help you determine which kernel modules you needto load to use lm_sensors most effectively. It is generally safeand recommended to accept the default answers to all questions,unless you know what you're doing.Some south bridges, CPUs or memory controllers contain embedded sensors.Do you want to scan for them? This is totally safe. (YES/no): 一路敲 yes 即可，然后执行 sensors 命令可以看到 CPU 的温度： 123456789101112131415161718192021222324$ sensorspower_meter-acpi-0Adapter: ACPI interfacepower1: 18446.74 GW (interval = 2.00 s)coretemp-isa-0000Adapter: ISA adapterPhysical id 0: +41.0°C (high = +75.0°C, crit = +85.0°C)Core 0: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +28.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +34.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +30.0°C (high = +75.0°C, crit = +85.0°C)coretemp-isa-0001Adapter: ISA adapterPhysical id 1: +38.0°C (high = +75.0°C, crit = +85.0°C)Core 0: +33.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +34.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +31.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +31.0°C (high = +75.0°C, crit = +85.0°C) 命令显示的结果是每个核心的温度以及物理核的温度，最后要聚合到一个数值上。这里可以选择两个方向，一是对每个核心进行监控，这样较为复杂，但是细节明显；二是对每个核心取平均值，处理比较简单。这里我选择了后者，那么就需要从命令输出中获取到需要的信息了。这里就用 grep，cut，awk 乱处理一通了。 首先用 grep 拿到每个核心的温度行： 12345678910111213$ sensors | grep \"Core\"Core 0: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +34.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +31.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 0: +31.0°C (high = +75.0°C, crit = +85.0°C)Core 1: +33.0°C (high = +75.0°C, crit = +85.0°C)Core 2: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 3: +30.0°C (high = +75.0°C, crit = +85.0°C)Core 4: +32.0°C (high = +75.0°C, crit = +85.0°C)Core 5: +31.0°C (high = +75.0°C, crit = +85.0°C) 然后用 cut 或者 awk 获取每行的温度数值。 12345678910111213$ sensors | grep \"Core\" | awk '&#123;print $3&#125;' | awk -F '.' '&#123;print $1&#125;' | awk -F '+' '&#123;print $2&#125;'303329343030313432323230 最后对这些输出按行取平均，再四舍五入到整数就行了（也可以不四舍五入）。 123$ sensors | grep 'Core' | awk '&#123;print $3&#125;' | awk -F \".\" '&#123;print $1&#125;' | awk -F \"+\" '&#123;print $2&#125;' | \\awk '&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;' | awk -F. '&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;'31 集成做完数据的采集工作，那么就要集成进 Zabbix 里了。首先需要在 zabbix_agentd 里定义这个监控项，在 zabbix_agentd.conf 里加入 1UserParameter=system.cpu.temperature,/usr/bin/sensors | grep &apos;Core&apos; | awk &apos;&#123;print $3&#125;&apos; | awk -F &quot;.&quot; &apos;&#123;print $1&#125;&apos; | awk -F &quot;+&quot; &apos;&#123;print $2&#125;&apos; | awk &apos;&#123;sum+=$1;count+=1&#125; END &#123;print sum/count&#125;&apos; | awk -F. &apos;&#123;if(substr($2,1,1)&gt;=5)$1+=1 ; print $1&#125;&apos; 然后重启 agent 服务即可。 123$ service zabbix_agentd restartShutting down zabbix_agentd: [ OK ]Starting zabbix_agentd: [ OK ] 回到 Zabbix 的界面，选择一个合适的模板，进到它的监控项中，点击新建监控项，然后如下图填入信息即可。注意这里的键值即上面填的 UserParameters 里的 key。 然后对相应的主机应用这个模板，那么就可以获取到这台主机的 CPU 温度了。 报警设置和普通监控项相同，如下： 最后，如果对 Zabbix 增加了 grafana 的话，还可以在 grafana 里去显示 CPU 温度。","categories":[{"name":"系统运维","slug":"系统运维","permalink":"http://mikasa.github.io/categories/系统运维/"}],"tags":[{"name":"zabbix","slug":"zabbix","permalink":"http://mikasa.github.io/tags/zabbix/"},{"name":"lm_sensors","slug":"lm-sensors","permalink":"http://mikasa.github.io/tags/lm-sensors/"},{"name":"cpu","slug":"cpu","permalink":"http://mikasa.github.io/tags/cpu/"}],"keywords":[{"name":"系统运维","slug":"系统运维","permalink":"http://mikasa.github.io/categories/系统运维/"}]},{"title":"使用slurm进行集群的资源管理（vagrant）","slug":"Ubuntu-瀹夎涓庝娇鐢⊿lurm","date":"2016-05-30T01:42:48.000Z","updated":"2016-11-24T07:16:14.134Z","comments":true,"path":"2016/05/30/Ubuntu-瀹夎涓庝娇鐢⊿lurm/","link":"","permalink":"http://mikasa.github.io/2016/05/30/Ubuntu-瀹夎涓庝娇鐢⊿lurm/","excerpt":"简介 SLURM 是一种可用于大型计算节点集群的高度可伸缩和容错的集群管理器和作业调度系统。SLURM 维护着一个待处理工作的队列并管理此工作的整体资源利用。它还以一种排他或非排他的方式管理可用的计算节点（取决于资源的需求）。最后，SLURM 将作业分发给一组已分配的节点来执行工作并监视平行作业至其完成。","text":"简介 SLURM 是一种可用于大型计算节点集群的高度可伸缩和容错的集群管理器和作业调度系统。SLURM 维护着一个待处理工作的队列并管理此工作的整体资源利用。它还以一种排他或非排他的方式管理可用的计算节点（取决于资源的需求）。最后，SLURM 将作业分发给一组已分配的节点来执行工作并监视平行作业至其完成。 slrum相当于一个集群管理器，可以伸缩至大型节点集群，容错好，而更重要的是他开源。而现在，slurm已经成为很多强大的超级计算机上使用的资源管理器。 架构slurm的架构和一般的集群管理架构相类似，顶部是一对冗余集群控制器，它充当计算集群的管理器并实现一个管理守护程序（slurmctld），slurmctld提供了对计算资源的监视，同时它将进入的作业映射到基本的计算资源。 此外，每个计算节点上有一个守护程序slurmd，slurmd负责管理在其上执行的节点包括运行的任务，来自控制器的工作，以及接受控制器的请求等。 安装安装上，为了模拟集群的环境，需要使用多个节点，所以我们用vagrant创建多个虚拟机。Vagrantfile如下： 123456789101112131415161718# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(2) do |config| config.vm.box = &quot;ubuntu/trusty64&quot; config.ssh.insert_key = false config.vm.define &quot;master&quot; do |node| node.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.10&quot; node.vm.hostname = &quot;master&quot; node.vm.provider &quot;virtualbox&quot; do |v| v.memory = 2048 v.cpus = 2 end end config.vm.define &quot;compute&quot; do |slave| slave.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.11&quot; slave.vm.hostname = &quot;compute&quot; endend 分别使用vagrant up master和vagrant up compute启动控制节点和计算节点。 Ubuntu源里提供了munge，所以可以直接通过源进行安装。在控制节点和计算节点分别安装slurm包，这个包里包含了slurmctld和slurmd 1$ sudo apt-get install slurm-llnl 由于计算节点和控制节点需要通信，而通信之间需要进行认证，所以这里需要生成key并启动认证服务。这里使用的是llnl的munge。 12$ sudo create-munge-keyGenerating a pseudo-random key using /dev/urandom complete. 然后启动munge的认证服务 1$ sudo service munge start 接下来配置slurm的配置文件，然而笔者在使用时，slrum的配置工具Slurm Configuration Tool失效了，所以可以去slurm的源码里复制一份example。我的配置文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940ClusterName=vagrantControlMachine=master#ControlAddr=#SlurmUser=slurmSlurmctldPort=6817SlurmdPort=6818AuthType=auth/mungeStateSaveLocation=/tmpSlurmdSpoolDir=/tmp/slurmdSwitchType=switch/noneMpiDefault=noneSlurmctldPidFile=/var/run/slurmctld.pidSlurmdPidFile=/var/run/slurmd.pidProctrackType=proctrack/pgidReturnToService=0## TIMERSSlurmctldTimeout=300SlurmdTimeout=300InactiveLimit=0MinJobAge=300KillWait=30Waittime=0## SCHEDULINGSchedulerType=sched/backfillSelectType=select/linearFastSchedule=1## LOGGINGSlurmctldDebug=3SlurmdDebug=3JobCompType=jobcomp/none## ACCOUNTING## COMPUTE NODESNodeName=compute Procs=1 State=UNKNOWNPartitionName=debug Nodes=compute Default=YES MaxTime=INFINITE State=UP 这份配置文件在计算节点上同样要使用，所以要复制到计算节点上。 1$ sudo scp /etc/slurm-llnl/slurm.conf vagrant@compute/~ 然后启动控制节点上的slurmctld服务： 12$ sudo service slurm-llnl start* Starting slurm central management daemon slurmctld 接着是计算节点的配置，同样需要使用munge，将控制节点生成的munge.key拷贝到计算节点上。 1$ sudo scp /etc/munge/munge.key vagrant@compute:/~ 然后进入计算节点，将munge.key拷贝到munge的目录并启动munge,注意要修改key的owner和group为munge。 12$ sudo mv ~/munge.key /etc/munge/$ sudo chown munge:munge /etc/munge/munge.key 然后就可以启动munge服务了 1$ sudo service munge start 再将之前复制的slurm.conf放到指定位置： 1$ mv ~/slurm.conf /etc/slurm-llnl/slurm.conf 接着启动计算节点上的slurmd 1$ sudo service slurm-llnl start 这样，slurm就配置完毕了。 使用这里就简单测试下slurm的功能（在控制节点上运行），首先运行sinfo查看集群状况。 123$ sinfoPARTITION AVAIL TIMELIMIT NODES STATE NODELISTdebug* up infinite 1 idle compute 然后启动一个任务（/bin/hostname）： 12$ srun -N1 /bin/hostnamecompute 错误与解决方案1. 启动munge报错误munged: Error: Logfile is insecure: group-writable permissions set on “/var/log” 在Ubuntu 14.04下启动munge会出现以下错误： 123$ sudo service munge start * Starting MUNGE munged [fail]munged: Error: Logfile is insecure: group-writable permissions set on &quot;/var/log&quot; 原因是因为Ubuntu 14.04将/var/log目录的权限从0755 root:root调整为0755 root:syslog，因此直接启动会报group-writable permissions的错误。 解决方案是启动munge时加上--force或--syslog的参数。 --force会将errors转为warnings，跳过错误 --syslog会跳过/var/log目录的权限检查 如果是使用/etc/init.d/munge start或者service munge start的话，可以将Option写到配置文件/etc/default/munge里： 1OPTIONS=&quot;--force&quot;","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"资源管理","slug":"资源管理","permalink":"http://mikasa.github.io/tags/资源管理/"},{"name":"集群","slug":"集群","permalink":"http://mikasa.github.io/tags/集群/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"OSX系统列举USB设备方法","slug":"OSX绯荤粺鍒椾妇USB璁惧鏂规硶","date":"2016-03-13T13:38:34.000Z","updated":"2016-11-24T07:16:14.118Z","comments":true,"path":"2016/03/13/OSX绯荤粺鍒椾妇USB璁惧鏂规硶/","link":"","permalink":"http://mikasa.github.io/2016/03/13/OSX绯荤粺鍒椾妇USB璁惧鏂规硶/","excerpt":"Linux 用户在列举USB设备时，可以使用lsusb命令来查看所有已经连接的usb设备，或者进入/dev/bus/usb/001之类进行查看。","text":"Linux 用户在列举USB设备时，可以使用lsusb命令来查看所有已经连接的usb设备，或者进入/dev/bus/usb/001之类进行查看。 而在Mac OS下，系统自带的命令则是system_profiler SPUSBDataType，使用这条命令可以查看所有连接的USB设备，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 jeff@promote ⮀ ~ ⮀ system_profiler SPUSBDataTypeUSB: USB 3.0 Bus: BSD Name: en4 Host Controller Driver: AppleUSBXHCIWPT PCI Device ID: 0x9cb1 PCI Revision ID: 0x0003 PCI Vendor ID: 0x8086 USB3.0 Hub: Product ID: 0x0612 Vendor ID: 0x05e3 (Genesys Logic, Inc.) Version: 92.16 Speed: Up to 5 Gb/sec Manufacturer: GenesysLogic Location ID: 0x14400000 / 6 Current Available (mA): 1800 Current Required (mA): 0 Extra Operating Current (mA): 0 Bluetooth USB Host Controller: Product ID: 0x8290 Vendor ID: 0x05ac (Apple Inc.) Version: 1.11 Speed: Up to 12 Mb/sec Manufacturer: Broadcom Corp. Location ID: 0x14300000 / 2 Current Available (mA): 1000 Current Required (mA): 0 Extra Operating Current (mA): 0 Built-In: Yes Razer DeathAdder: Product ID: 0x0016 Vendor ID: 0x1532 Version: 1.00 Speed: Up to 12 Mb/sec Manufacturer: Razer Location ID: 0x14200000 / 4 Current Available (mA): 1000 Current Required (mA): 100 Extra Operating Current (mA): 0 USB2.0 Hub: Product ID: 0x0610 Vendor ID: 0x05e3 (Genesys Logic, Inc.) Version: 92.16 Speed: Up to 480 Mb/sec Manufacturer: GenesysLogic Location ID: 0x14100000 / 5 Current Available (mA): 1000 Current Required (mA): 100 Extra Operating Current (mA): 0 BSD Name: en4 Apple USB Ethernet Adapter: Product ID: 0x1402 Vendor ID: 0x05ac (Apple Inc.) Version: 0.01 Serial Number: 1460AB Speed: Up to 480 Mb/sec Manufacturer: Apple Inc. Location ID: 0x14140000 / 7 Current Available (mA): 1000 Current Required (mA): 250 Extra Operating Current (mA): 0 BSD Name: en4 iPhone: Product ID: 0x12a8 Vendor ID: 0x05ac (Apple Inc.) Version: 7.02 Serial Number: 1ba089f6c8745ae921e95dea83879c7e36b43b9c Speed: Up to 480 Mb/sec Manufacturer: Apple Inc. Location ID: 0x14130000 / 8 Current Available (mA): 1000 Current Required (mA): 500 Extra Operating Current (mA): 0 Sleep current (mA): 500 而在图形界面上EL Capitan的操作步骤为： 点击左上角苹果标志 点击关于本机-&gt; 系统报告 -&gt; USB 然后则可以查看系统总线上挂载的USB信息了 最后说下为啥写这个：最近在研究怎么在docker container中挂载USB，首先要获取总线上的USB设备，这是个开头吧。","categories":[],"tags":[{"name":"系统运维","slug":"系统运维","permalink":"http://mikasa.github.io/tags/系统运维/"}],"keywords":[]},{"title":"运行Mesos Framework报no mesos in java.library.path解决方法","slug":"杩愯Mesos-Framework鎶o-mesos-in-java-library-path瑙ｅ喅鏂规硶","date":"2016-01-05T07:08:33.000Z","updated":"2016-11-24T07:16:14.524Z","comments":true,"path":"2016/01/05/杩愯Mesos-Framework鎶o-mesos-in-java-library-path瑙ｅ喅鏂规硶/","link":"","permalink":"http://mikasa.github.io/2016/01/05/杩愯Mesos-Framework鎶o-mesos-in-java-library-path瑙ｅ喅鏂规硶/","excerpt":"在运行自己用scala编写的Framework时遇到了一个巨大的问题，即","text":"在运行自己用scala编写的Framework时遇到了一个巨大的问题，即在执行 1java -cp xxxx.jar -Djava.library.path=libs xxxx.xxxx.xxx 之后报错： 12345Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: no mesos in java.library.path at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1758) at java.lang.Runtime.loadLibrary0(Runtime.java:823) at java.lang.System.loadLibrary(System.java:1045) at org.apache.mesos.MesosNativeLibrary.load(MesosNativeLibrary.java:46) 尝试了把build之后的mesos-0.25.0.jar和protobuf-2.5.0.jar加入，依然不生效，查询了stackoverflow后发现是MESOS_NATIVE_LIBRARY环境变量未加入。 因此只要执行 12345 # For Linux$ export MESOS_NATIVE_LIBRARY=&apos;/usr/local/lib/libmesos.so&apos; # For OSX$ export MESOS_NATIVE_LIBRARY=&apos;/usr/local/lib/libmesos.dylib&apos; 就行了。 为了方便，可以把这个语句加到.bashrc中","categories":[{"name":"设计开发","slug":"设计开发","permalink":"http://mikasa.github.io/categories/设计开发/"}],"tags":[{"name":"mesos","slug":"mesos","permalink":"http://mikasa.github.io/tags/mesos/"},{"name":"bugfix","slug":"bugfix","permalink":"http://mikasa.github.io/tags/bugfix/"}],"keywords":[{"name":"设计开发","slug":"设计开发","permalink":"http://mikasa.github.io/categories/设计开发/"}]},{"title":"DCOS上的cron 分布式作业调度器 Chronos","slug":"DCOS涓婄殑cron-鍒嗗竷寮忎綔涓氳皟搴﹀櫒-Chronos","date":"2015-12-28T13:34:27.000Z","updated":"2016-11-24T07:16:13.978Z","comments":true,"path":"2015/12/28/DCOS涓婄殑cron-鍒嗗竷寮忎綔涓氳皟搴﹀櫒-Chronos/","link":"","permalink":"http://mikasa.github.io/2015/12/28/DCOS涓婄殑cron-鍒嗗竷寮忎綔涓氳皟搴﹀櫒-Chronos/","excerpt":"Chronos是Aribnb公司开发的替代cron的Mesos框架。它是一个运行在Apache Mesos上的分布式的，高容错的任务编排、定时任务的框架。","text":"Chronos是Aribnb公司开发的替代cron的Mesos框架。它是一个运行在Apache Mesos上的分布式的，高容错的任务编排、定时任务的框架。 Chronos作为DCOS中的一部分，它默认所处的环境下存在任务的环境。例如Chronos会执行Hadoop任务脚本，即使执行的slave上并没有Hadoop环境（但是这样会导致任务的失败）。此外，Chronos支持任务脚本传输文件到远程机器上，并执行文件，同时接受异步的回调，通知Chronos任务成功或是失败。比较重要的一点是，Chronos同样支持在Docker容器中进行执行任务。 架构 Chronos通过Mesos Master下的Scheduler选择指定slave执行job，来完成相应的task。而在Chronos中并不会对环境进行选择，而只是对从Mesos Master接受的Resource offers进行筛选。 JobGraphChronos中比较重要的一点是利用JobGraph来确定各个job之间的依赖关系，以确定任务执行的先后顺序。 Chronos中根据JobGraph计算出job执行的优先级，然后再根据当前的job执行情况，然后确定每个任务是否进行执行。 如图，我创建了2个任务: 指定sleep2的父元素为sleep，则sleep2依赖于sleep，先后顺序也应该为先执行sleep然后是sleep2，如下图(绿色代表已经执行，白色代表未执行) 而实际生产中JobGraph的图是非常复杂的，因此Chronos利用JobGraph能够很有效的进行任务的调度。 部分源码解析这里主要分析framework部分的主要核心代码： resourceOffers() 123456789101112131415161718192021222324252627282930//该方法实现调用mesos的scala接口，进行offer的分配 def resourceOffers(schedulerDriver: SchedulerDriver, receivedOffers: java.util.List[Offer]) &#123; log.info(\"Received resource offers\") import scala.collection.JavaConverters._ val offers = receivedOffers.asScala.toList val offerResources = mutable.HashMap(offers.map(o =&gt; (o, Resources(o))).toSeq: _*) //生成可以执行的task(详细见下文) val tasksToLaunch = generateLaunchableTasks(offerResources) log.info(\"Declining unused offers.\") // 创建一个Set保存已经使用的offer val usedOffers = mutable.HashSet(tasksToLaunch.map(_._3.getId.getValue): _*) //如果当前的offer已经被使用了（在usedOffers里出现），则decline掉 offers.foreach(o =&gt; &#123; if (!usedOffers.contains(o.getId.getValue)) mesosDriver.get().declineOffer(o.getId, declineOfferFilters) &#125;) log.info(s\"Declined unused offers with filter refuseSeconds=$&#123;declineOfferFilters.getRefuseSeconds&#125; \" + s\"(use --$&#123;config.declineOfferDuration.name&#125; to reconfigure)\") //执行任务 launchTasks(tasksToLaunch) // Perform a reconciliation, if needed. reconcile(schedulerDriver) &#125; generateLaunchableTasks（） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 def generateLaunchableTasks(offerResources: mutable.HashMap[Offer, Resources]): mutable.Buffer[(String, BaseJob, Offer)] = &#123; val tasks = mutable.Buffer[(String, BaseJob, Offer)]() // 属性约束检查 def checkConstraints(attributes: Seq[Protos.Attribute], constraints: Seq[Constraint]): Boolean = &#123; //遍历所有的属性约束 constraints.foreach &#123; c =&gt; if (!c.matches(attributes)) &#123; return false &#125; &#125; true &#125;//尾递归注解 @tailrec def generate() &#123; taskManager.getTask match &#123; case None =&gt; log.info(\"No tasks scheduled or next task has been disabled.\\n\") case Some((taskId, job)) =&gt; if (runningTasks.contains(job.name)) &#123; // 若当前的task正在执行，则从taskManager里将其去除 val deleted = taskManager.removeTask(taskId) log.warning(\"The head of the task queue appears to already be running: \" + job.name + \"\\n\") // 递归调用 generate() &#125; else &#123; tasks.find(_._2.name == job.name) match &#123; case Some((subtaskId, subJob, offer)) =&gt; //若发现已经调度的任务出现在队列中，则将其删除 val deleted = taskManager.removeTask(subtaskId) log.warning(\"Found job in queue that is already scheduled for launch with this offer set: \" + subJob.name + \"\\n\") //递归调用 generate() case None =&gt; //生产当前任务所需的资源，并且判断每个offer的各个资源是否能够满足 val neededResources = new Resources(job) offerResources.toIterator.find &#123; ors =&gt; ors._2.canSatisfy(neededResources) &amp;&amp; checkConstraints(ors._1.getAttributesList.asScala, job.constraints) &#125; match &#123; case Some((offer, resources)) =&gt; //若存在资源能够满足 // Subtract this job's resource requirements from the remaining available resources in this offer. //计算新资源，执行任务 resources -= neededResources tasks.append((taskId, job, offer)) //继续递归 generate() case None =&gt; // 资源不足，则将task重新加回队列（taskManager） val foundResources = offerResources.toIterator.map(_._2.toString()).mkString(\",\") log.warning( \"Insufficient resources remaining for task '%s', will append to queue. (Needed: [%s], Found: [%s])\" .stripMargin.format(taskId, neededResources, foundResources) ) taskManager.enqueue(taskId, job.highPriority) &#125; &#125; &#125; &#125; &#125; generate() tasks &#125; 从这段源码中可以看出来taskManaer事实上是一个task的优先队列。同时从generateLaunchableTasks()这个函数看出Chronos利用Scala的尾递归巧妙地处理了所有情况，保证调度器工作的执行。 总结Chronos是一个非常好的Mesos框架，同时它的源码采用scala语言进行编写，函数式编程也让代码看起来非常的舒畅。由于笔者毕业设计打算写一个Mesos Framework，所以Chronos是一个很好的典范！","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"mesos","slug":"mesos","permalink":"http://mikasa.github.io/tags/mesos/"},{"name":"chronos","slug":"chronos","permalink":"http://mikasa.github.io/tags/chronos/"},{"name":"批处理","slug":"批处理","permalink":"http://mikasa.github.io/tags/批处理/"},{"name":"脚本","slug":"脚本","permalink":"http://mikasa.github.io/tags/脚本/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"Mesos Authentication详解","slug":"Mesos-Authentication璇﹁В","date":"2015-12-28T09:01:24.000Z","updated":"2016-11-24T07:16:14.056Z","comments":true,"path":"2015/12/28/Mesos-Authentication璇﹁В/","link":"","permalink":"http://mikasa.github.io/2015/12/28/Mesos-Authentication璇﹁В/","excerpt":"Authentication模块是Mesos中较为重要的一部分，涉及了整个系统的安全性。Mesos 0.15.0引入了framework authentication，0.19.0引入了slave authentication。Mesos Authentication只允许信任的实体可以和Mesos集群进行交互。","text":"Authentication模块是Mesos中较为重要的一部分，涉及了整个系统的安全性。Mesos 0.15.0引入了framework authentication，0.19.0引入了slave authentication。Mesos Authentication只允许信任的实体可以和Mesos集群进行交互。 Mesos中的Authentication模块常用使用方法有三种： 要求framework必须被授权才能向master注册 要求slaves必须被授权才能获得resources offer 限制/teardown端的访问 工作原理Mesos的Authentication模块使用了Cyrus SASL Library实现验证。SASL提供了多种验证机制，包括（ANOYMOUS,PLAIN,’CRAM-MD5,GSSAPI`等）。 现在Mesos默认支持CRAM-MD5进行验证，单用户可以拓展自己的authentication modules（详见之后的文章mesos modules）。CRAM-MD5使用principal和secret对进行验证，其中principal代表framework的身份。注意，这里的framework并不是执行framework的user而是framework自身 配置在启动mesos节点时可以通过配置项来选择是否启用authentication模块，对哪些部分启用authentication。 Masters -authenticate/-no-authenticate 前者只允许授权的framework接入集群，后者还允许未授权的framework接入 -authenticate_slaves/-no-authenticate_slaves 前者只允许授权的slave介入集群，后者还允许未授权的framework接入 -authenticators 指定选用的authenticator module默认是crammd5，用户可以通过-modules选项进行拓展 -credentials 指定证书路径（可能因authenticator module不同而不一定使用该选项） Slaves -authenticatee 指定slave使用哪个authenticator module和master的authenticators进行授权。默认是crammd5 -credential 指定证书路径 例子这里使用默认的CRAM-MD5进行验证。 1.创建credentials文件 首先为master创建credentials文件，其中的内容像如下所示： 12principal1 secret1principal2 secret2 2. 启动master 然后启动master,并使用我们刚刚生成的credentials文件1/bin/mesos-master.sh --ip=127.0.0.1 --work_dir=/var/lib/mesos --authenticate --authenticate_slaves --credentials=~/credentials 3.创建slave的credentials 像步骤1一样创建slave的credentials 1principal1 secret1 4.启动slave 启动slave并进行验证： 1./bin/mesos-slave.sh --master=127.0.0.1:5050 --credential=~/slave_credential 6.framework验证 不同的framework的验证方法可能不同，可以写入scheduler driver的构造方法中，也可以在启动框架时加入，如下： 1MESOS_AUTHENTICATE=true DEFAULT_PRINCIPAL=principal2 DEFAULT_SECRET=secret2 ./src/test-framework --master=127.0.0.1:5050 结果： 使用credentials验证成功的slave: 未使用credentials验证的slave: 可以看到未使用的slave无法进行注册","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"mesos","slug":"mesos","permalink":"http://mikasa.github.io/tags/mesos/"},{"name":"authentication","slug":"authentication","permalink":"http://mikasa.github.io/tags/authentication/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"Mesos Monitoring机制总结","slug":"Mesos-Monitoring鏈哄埗鎬荤粨","date":"2015-12-23T14:24:56.000Z","updated":"2016-11-24T07:16:14.103Z","comments":true,"path":"2015/12/23/Mesos-Monitoring鏈哄埗鎬荤粨/","link":"","permalink":"http://mikasa.github.io/2015/12/23/Mesos-Monitoring鏈哄埗鎬荤粨/","excerpt":"Mesos的master和slave提供了一组统计数据和指标，使用户能够方便地监控资源使用情况并且尽早发现异常状态。Mesos的监控包括可用资源，已经使用的资源，已经注册的框架，活跃的slave和任务的状态等。开发者可以利用这些监控信息实现自动化的报警，也可以在监控界面里绘制动态的监控图表。","text":"Mesos的master和slave提供了一组统计数据和指标，使用户能够方便地监控资源使用情况并且尽早发现异常状态。Mesos的监控包括可用资源，已经使用的资源，已经注册的框架，活跃的slave和任务的状态等。开发者可以利用这些监控信息实现自动化的报警，也可以在监控界面里绘制动态的监控图表。 指标Mesos提供了两种不同的指标：counter和gauge。 counter（计数器）用来跟踪不连续的事件。它是单向递增的，并且它的类型是自然数。典型的例子就是失败的任务数量、注册的slave数量等。对于这类指标，变化率比数值本身更加重要。 gauge(我也不知道怎么翻译好）代表一瞬间的某个属性的测量值。例如当前集群中使用内存的总量，在线的slave连接数量。这类指标通常用来监控其是否在一段时间内高于或低于一个阈值（即是否异常）。 MasterapiMaster节点的指标对外提供了api，具体可通过浏览器访问1http://&lt;master-ip&gt;:5050/metrics/snapshot 来进行获取，访问该链接(GET请求）会返回一组JSON串，内容为指标名称和内容的键值对。 1. 指标内容：Slave总资源属于该类别的指标主要包括整个集群的可用资源总量和当前已经使用的资源部分。如果资源使用量持续高举不下，说明应该增加集群的资源总量，或者集群内的某个Framework已经运行失常。 指标 说明 类型 master/cpus_percent 已使用的CPU占总量百分比 Gauge master/cpus_used 已使用的CPU的个数 Gauge master/cpus_total CPU的总数 Gauge master/cpus_revocable_percent 可回收 Gauge master/cpus_revocable_total Number of revocable CPUs Gauge master/cpus_revocable_used Number of allocated revocable CPUs Gauge master/disk_percent 已使用的磁盘空间占总量百分比 Gauge master/disk_used 已使用的磁盘空间(MB为单位) Gauge master/disk_used 已使用的磁盘空间(MB为单位) Gauge master/disk_total 磁盘总空间(MB为单位) Gauge master/disk_revocable_percent Percentage of allocated revocable disk space Gauge master/disk_revocable_total Revocable disk space in MB Gauge master/disk_revocable_used Allocated revocable disk space in MB Gauge master/mem_percent 已使用的内存占总量百分比 Gauge master/mem_used 已使用的内存（MB为单位） Gauge master/mem_total 内存总量（MB为单位） Gauge master/mem_revocable_percent Percentage of allocated revocable memory Gauge master/mem_revocable_total Revocable memory in MB Gauge master/mem_revocable_used Allocated revocable memory in MB Gauge 2. 指标内容：Master状态这部分的指标主要说明Master是否是leading master，它已经启动运行了多长时间。当一个集群经过一段时间依然没有选出leading master，则认为这个集群已经处于故障状态。这说明要么竞选过程出现问题（检查 ZooKeeper 的连接），要么选出的 Master 有故障。此外较短的已经运行时间表明Master近期有过重启。 指标 说明 类型 master/elected 是否是 leading master Gaude master/uptime_secs 已经运行时间（秒） Gaude 3. 指标内容：Master资源这部分的指标主要说明指定Master的资源总量和使用情况。Master节点资源使用率长期高居不下，可能会影响集群的整体性能。区别于1中的资源，以下的system的资源特指Master的资源，而1中为Slave的总体资源情况 指标 说明 类型 system/cpus_total 在这个master的可用 CPU 的数量 Guage system/load_15min 过去15分钟的平均负载 Guage system/load_5min 过去5分钟的平均负载 Guage system/load_1min 过去1分钟的平均负载 Guage system/mem_free_bytes 空闲内存的字节数 Guage system/mem_total_bytes 全部内存的字节数 Guage 4. 指标内容：Slave状态改部分的指标主要包括Slave的事件、Slave数量和Slave状态的信息。活跃的Slave数量过少表明这个集群的Slave不健康，或者它们无法连接到当前的leading master。 指标 说明 类型 master/slave_registrations 能够顺利地完成与Master断开然后 重联的Slave的数量 Counter master/slave_removals 各种原因被删除的Slave数量，包括维护 Counter master/slave_reregistrations 重新注册的 slave 的数目 Counter master/slave_shutdowns_scheduled 因为健康检查失败而被计划删除 的 slave 的数量。由于对删除 slave 的速度有限制（Slave Removal Rate-Limit），所以它们不一定会立即被删除。 当他们真正被删掉，指标 master/slave_shutdowns_completed 会增加。 Counter master/slave_shutdowns_cancelled 被取消的删除 slave 操作的数量。 发生在因为删除 Slave 有限速，slave 在被删除之前有机会成功重连并且发送 PONG 给 master Counter master/slave_shutdowns_completed 成功地被删除了的 Slave 的数量 Counter master/slaves_active 活跃的 slave 的数量 Guage master/slaves_connected 连接在线的 slave 的数量 Guage master/slaves_disconnected 断开离线的 slave 的数量 Guage master/slaves_inactive 不活跃的 slave 的数量 Guage","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"mesos","slug":"mesos","permalink":"http://mikasa.github.io/tags/mesos/"},{"name":"监控","slug":"监控","permalink":"http://mikasa.github.io/tags/监控/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"杭电校赛部分赛题题解","slug":"鏉數鏍¤禌閮ㄥ垎璧涢棰樿В","date":"2015-11-29T14:16:08.000Z","updated":"2016-11-24T07:16:14.430Z","comments":true,"path":"2015/11/29/鏉數鏍¤禌閮ㄥ垎璧涢棰樿В/","link":"","permalink":"http://mikasa.github.io/2015/11/29/鏉數鏍¤禌閮ㄥ垎璧涢棰樿В/","excerpt":"下午大家在做题的时候我把后面几个题目写了写，写一个题解和大家分享。简单题大家自己讨论下，可能有什么坑的，自己细心点就行了。这里主要写一下1003，1005，1006，1007的题解。下午没怎么认真做，代码写的乱七八糟，大家见谅。","text":"下午大家在做题的时候我把后面几个题目写了写，写一个题解和大家分享。简单题大家自己讨论下，可能有什么坑的，自己细心点就行了。这里主要写一下1003，1005，1006，1007的题解。下午没怎么认真做，代码写的乱七八糟，大家见谅。 1003 玩骰子题意两个人扔骰子，根据规则（有三条、对子、散牌什么的，具体看题）比较大小，大的人赢。现在主角已经扔了一个结果了，然后对方也扔了一个结果，主角有一个机会选择一个数重新扔一次，问获胜的几率有多少。 这里有个需要理解一下的地方，因为主角很机智，所以肯定不会选择毫无胜算的数字来重新扔（就是选择了一个数字，重新扔骰子，扔出来的数字不管是多少都不会改变输的结果），所以算概率的时候分母注意一下不是全部的可能性，而是选择的可能性。 分析这题就是个大模拟。。写一个结构体把比较函数写清楚了（注意罗列所有情况），然后暴力枚举吧，注意如果win的数量为0，就不要加tot了，然后取所有数里面赢的概率最大的为结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int x, int y)&#123; return x &gt; y;&#125;int vis[6];struct node&#123; int n[3]; int t; int tn; int tnn; node(int a, int b, int c)&#123; n[0] = a; n[1] = b; n[2] = c; sort(n, n+3, cmp); if(n[0] == n[2])&#123; t = 3; tn = n[0]; &#125;else if(n[0] == n[1])&#123; t = 2; tn = n[1]; tnn = n[2]; &#125;else if(n[1] == n[2])&#123; t = 2; tn = n[1]; tnn = n[0]; &#125;else&#123; t = 1; tn = n[0]; &#125; &#125; int ncmp(node y)&#123; if(t == y.t)&#123; if(t == 1)&#123; if(n[0] == y.n[0])&#123; if(n[1] == y.n[1])&#123; if(n[2] == y.n[2])&#123; return 2; &#125;else&#123; return n[2] &gt; y.n[2]; &#125; &#125;else&#123; return n[1] &gt; y.n[1]; &#125; &#125;else&#123; return n[0] &gt; y.n[0]; &#125; &#125;else if(t==2)&#123; if(tn == y.tn)&#123; return tnn &gt; y.tnn; &#125;else&#123; return tn &gt; y.tn; &#125; &#125;else &#123; return n[0] &gt; y.n[0]; &#125; &#125;else&#123; return t &gt; y.t; &#125; &#125; void print()&#123; cout&lt;&lt;n[0]&lt;&lt;\" \"&lt;&lt;n[1]&lt;&lt;\" \"&lt;&lt;n[2]&lt;&lt;\" \"&lt;&lt;t&lt;&lt;endl; &#125;&#125;;int main()&#123; int a, b, c,d,e,f; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%d%d%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f); node x = node(a,b,c); node y = node(d,e,f); // x.print(); // y.print(); // cout&lt;&lt;x.ncmp(y)&lt;&lt;endl; if(x.ncmp(y)==1)&#123; printf(\"%.3lf\\n\", 1.0); continue; &#125; int tot = 6; int win = 0; double ans = 0; for(int i = 1; i &lt;=6; i++)&#123; node z = node(i,b,c); if(z.ncmp(y)==1)&#123; win++; &#125; &#125; ans = max(ans,(double)win/(double)tot); win = 0; for(int i = 1; i &lt;=6; i++)&#123; node z = node(a,i,c); if(z.ncmp(y)==1)&#123; win++; &#125; &#125; ans = max(ans,(double)win/(double)tot); win = 0; for(int i = 1; i &lt;=6; i++)&#123; node z = node(a,b,i); if(z.ncmp(y)==1)&#123; win++; &#125; &#125; ans = max(ans,(double)win/(double)tot); printf(\"%.3f\\n\", ans); &#125;&#125; ACM组队安排题意n个人组队，每队人数可以为1或2或3，问组队的方案数。 思路12345void dfs(int a, int b, int c)&#123; //a为组队人数3的队伍数，b为组队人数2的队伍数，类推。。。 dfs(a,b+1,c-2) //取两个孤立的人组成一队2个人的 dfs(a+1,b-1,c-1) //取1个孤立的人和1队2人的组成1队3人的&#125; 为了把所有状态都搜遍，我们从dfs(0,0,n)开始，按上述的搜索方法进行搜索，标记已经访问过的状态vis[a][b][c]。 然后对于某个状态(a,b,c)，求方案数用排列组合的思路搞搞就出来了。 例如(1,2,1)，方案数是C(3,8)/1! * (C(2,5) * C(2,3))/2! * C(1,1)/1!。具体就是，8个人挑3个人，5个人挑2个，3个人挑2个，剩下1个人, 各算出方案数，然后乘法原理乘一下就是的了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longusing namespace std;ll ans = 0;ll fact[11];int vis[25][25][25];void init()&#123; fact[1] = 1; for(int i = 2; i &lt;= 10; i++)&#123; fact[i] = fact[i-1]*i; &#125;&#125;ll c2(int n)&#123; if(n &lt; 2) return 1; return n*(n-1)/2;&#125;ll c3(int n)&#123; if(n &lt; 3) return 1; return n*(n-1)*(n-2)/6;&#125;ll sum(int a, int b, int c)&#123; ll t = 1; int k = a*3+b*2+c; for(int i = 1; i &lt;= a; i++)&#123; t *= c3(k); k -= 3; &#125; if(a) t/=fact[a]; for(int i = 1; i &lt;= b; i++)&#123; t *= c2(k); k -= 2; &#125; if(b) t/=fact[b]; return t;&#125;void dfs(int a, int b, int c)&#123; vis[a][b][c] = true; // cout&lt;&lt;a&lt;&lt;\" \"&lt;&lt;b&lt;&lt;\" \"&lt;&lt;c&lt;&lt;\" \"&lt;&lt;sum(a,b,c)&lt;&lt;endl; ans += sum(a,b,c); if(c-2&gt;=0 &amp;&amp; !vis[a][b+1][c-2])&#123; dfs(a, b+1, c-2); &#125; if(b-1 &gt;= 0 &amp;&amp; c-1 &gt;=0 &amp;&amp; !vis[a+1][b-1][c-1])&#123; dfs(a+1, b-1, c-1); &#125;&#125;int main()&#123; int n; init(); while(~scanf(\"%d\",&amp;n) &amp;&amp; n)&#123; ans = 0; memset(vis,0,sizeof(vis)); dfs(0,0,n); cout&lt;&lt;ans&lt;&lt;endl; // cout&lt;&lt;sum(1, 1, 0)&lt;&lt;endl; &#125;&#125; 以上思路为错误方法~~~(虽然可以过这道题)。 在写的时候忽然发现这是一道很简单的dp… 123f[i]=f[i-1];//第i个人自己组队f[i]+=f[i-2]*(i-1);//第i个人与前面i-1个人中的一个人组队，有i-1种方法，剩下的i-2个人进行组队，即f[i-2]种方法。f[i]+=f[i-3]*(i-1)*(i-2)/2;//前面的i-1个人中，挑2个人和第i个人组队(C(2,n-1)，剩余i-3个人组队(f(i-3)) 然后f[1]，f[2]，f[3]都告诉你了，然后你懂的了。。 所以大家还是按正确的方法写吧…ORZ~ 1006 逆袭指数题意给定一个数n，求n的最长的连续的因子，输出为i*(i+1)*(i+2)...。同时乘起来的因子还是n的因子。如630：5*6*7，5*6*7=210是630的因子。 分析直接上去暴力搞，枚举n的所有因子p，然后从p开始向后枚举，枚举到最长的时候就行。由于大多数因子连续都在前面的数里，所以复杂度不会很高。 注意：从p向后枚举时要枚举到n为止而不是sqrt(n)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;vector &lt;int&gt; fac;vector &lt;int&gt;::iterator it;bool vis[1000000];int ans = 0;vector&lt;int&gt; path;long long n;void dfs(int k)&#123; int len = 0; long long t = n; vector&lt;int&gt; v; for(int i = k; i &lt;= n; i++)&#123; if(t % i == 0)&#123; t /= i; vis[i] = true; len++; v.push_back(i); &#125;else&#123; break; &#125; &#125; if(len &gt; ans)&#123; ans = len; int size = v.size(); path.clear(); for(int i = 0; i &lt;= size; i++) path.push_back(v[i]); &#125;&#125;int main()&#123; while(~scanf(\"%lld\",&amp;n))&#123; ans = 0; int size = fac.size(); for(int i = 2; i*i &lt;= n; i++)&#123; dfs(i); &#125; size = path.size(); if(ans == 0)&#123; puts(\"1\"); cout&lt;&lt;n&lt;&lt;endl; continue; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i = 0; i &lt; ans; i++)&#123; if(i &lt; ans-1) cout&lt;&lt;path[i]&lt;&lt;\"*\"; else cout&lt;&lt;path[i]; &#125; cout&lt;&lt;endl; &#125;&#125; 1007 油菜花王国题意现在有n个精力，输入他们的能力k[i]，如果k[i]是斐波那契数，那么他的威望值f[i]为1，反之为0.然后给了m个关系(u,v)表示u和v是同一个家族，家族的威望是他们的和。最后求威望最大的家族的威望。 分析额，非常裸的并查集。 首先，斐波那契判断很方便，预处理一下存数组就行了。注意：不用快速幂什么的。。因为大概第45项就超过1000000000了。。，然后判断也就从前往后扫如果相等就返回。。反之随便搞搞。。 然后是并查集，直接上模板，记得合并merge操作的时候，把子节点的威望加到父节点上去。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longll fibo[50];int f[1050];int fa[1050];void init()&#123; fibo[1] = 1; fibo[2] = 1; for(int i = 3; i &lt;= 45; i++)&#123; fibo[i] = fibo[i-2] + fibo[i-1]; &#125;&#125;int check(int n)&#123; for(int i = 1; i &lt;= 45; i++)&#123; if(n == fibo[i]) return 1; if(n &lt; fibo[i]) return 0; &#125;&#125;int find(int x)&#123; if(x != fa[x]) fa[x] = find(fa[x]); return fa[x];&#125;void merge(int x,int y)&#123; int a = find(x),b = find(y); if(a != b)&#123; fa[b] = a; f[a] += f[b]; &#125;&#125;int main()&#123; init(); int n,m; while(~scanf(\"%d%d\",&amp;n,&amp;m))&#123; int u,v,t; memset(f,0,sizeof(f)); memset(fa,0,sizeof(fa)); for(int i = 1; i &lt;=n; i++)&#123; fa[i] = i; scanf(\"%d\",&amp;t); f[i] = check(t); &#125; for(int i = 0; i &lt; m; i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); merge(u,v); &#125; int ans = 0; for(int i = 1; i &lt;= 1000; i++)&#123; if(f[i] &gt; ans)&#123; ans = f[i]; &#125; &#125; printf(\"%d\\n\", ans); &#125;&#125; 最后说两句题目都很简单，大家最好在之后都去把没做出来的题目再做做，继续刷题！","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://mikasa.github.io/tags/并查集/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://mikasa.github.io/tags/记忆化搜索/"},{"name":"模拟","slug":"模拟","permalink":"http://mikasa.github.io/tags/模拟/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"给Mesos换一个新的WebUI","slug":"缁橫esos鎹竴涓柊鐨刉ebUI","date":"2015-11-23T10:29:00.000Z","updated":"2016-11-24T07:16:14.493Z","comments":true,"path":"2015/11/23/缁橫esos鎹竴涓柊鐨刉ebUI/","link":"","permalink":"http://mikasa.github.io/2015/11/23/缁橫esos鎹竴涓柊鐨刉ebUI/","excerpt":"虽然Mesos已经给用户提供了一个webui(http://master:5050)，然而这个UI无法很直观地显示集群的资源状况，因此可以给Mesos换一个更帅气的UI！","text":"虽然Mesos已经给用户提供了一个webui(http://master:5050)，然而这个UI无法很直观地显示集群的资源状况，因此可以给Mesos换一个更帅气的UI！ 依赖由于项目需要nodejs和npm环境，所以最好先配置好nodejs环境，最好node版本高于4.0，不然可能会出现错误。 然后是构建项目需要的gulp，运行 1sudo npm install -g gulp 就可以了 安装这里使用的是Capgemini group写的开源UI，首先感谢一下作者们~ 项目地址为Capgemini/mesos-ui 首先把整个项目clone下来 1git clone https://github.com/Capgemini/mesos-ui mesos-ui 然后安装相关的依赖 12cd mesos-uisudo npm install 最后使用gulp对项目进行build就行了 1gulp build 使用Mesos配置web地址非常方便，只需要在启动Mesos时添加webui_dir=your_webui_dir就好了 1./bin/mesos-master.sh --ip=127.0.0.1 --work_dir=/var/lib/mesos --webui_dir=your_webui_dir 如果你的Mesos是以service的形式存在（换句话说就是不用自己手动启），也可以这么搞export MESOS_WEBUI_DIR=/your-path/mesos-ui/build/，然后重启服务 1sudo service mesos-master restart 也就OK了 然后可以登陆127.0.0.1:5050去看看新UI了~","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"mesos","slug":"mesos","permalink":"http://mikasa.github.io/tags/mesos/"},{"name":"webui","slug":"webui","permalink":"http://mikasa.github.io/tags/webui/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"利用Docker和Marathon构建带数据分析的Web应用","slug":"鍒╃敤Docker鍜孧arathon鏋勫缓甯︽暟鎹垎鏋愮殑Web鏈嶅姟","date":"2015-11-16T11:33:33.000Z","updated":"2016-11-24T07:16:14.368Z","comments":true,"path":"2015/11/16/鍒╃敤Docker鍜孧arathon鏋勫缓甯︽暟鎹垎鏋愮殑Web鏈嶅姟/","link":"","permalink":"http://mikasa.github.io/2015/11/16/鍒╃敤Docker鍜孧arathon鏋勫缓甯︽暟鎹垎鏋愮殑Web鏈嶅姟/","excerpt":"利用搭建的Mesos、Marathon和Docker的环境，搭建一个带数据分析模块的Web应用。","text":"利用搭建的Mesos、Marathon和Docker的环境，搭建一个带数据分析模块的Web应用。 架构该应用是一个网上商店（mesosphere官网给的demo…)，是个虚构的在线商店，由(nginx+Redis)提供Web服务，同时通过ELK构建日志搜索部分。整个应用的架构如下： 整个应用的系统部分使用(Mesos+Marathon+Docker)构建，用的是之前我们用vagrant建好的集群。 方法下面记录下整个应用的构建步骤： (以下操作均在node1中进行) 首先从mesosphere官方的Github仓库clone下来所需要用到的配置和程序mhausenblas/m-shop。 1$ git clone https://github.com/mhausenblas/m-shop OK,然后我们要使用Marathon中的REST接口来处理之后的应用请求了 首先，查看所有的应用 12$ curl http://node1:8080/v2/apps&#123;&quot;apps&quot;:[&#123;&quot;id&quot;:&quot;/webapp&quot;,&quot;cmd&quot;:&quot;python -m SimpleHTTPServer&quot;,&quot;args&quot;:null,&quot;user&quot;:null,&quot;env&quot;:&#123;&#125;,&quot;instances&quot;:1,&quot;cpus&quot;:0.1,&quot;mem&quot;:16.0,&quot;disk&quot;:0.0,&quot;executor&quot;:&quot;&quot;,&quot;constraints&quot;:[],&quot;uris&quot;:[],&quot;storeUrls&quot;:[],&quot;ports&quot;:[10000],&quot;requirePorts&quot;:false,&quot;backoffSeconds&quot;:1,&quot;backoffFactor&quot;:1.15,&quot;maxLaunchDelaySeconds&quot;:3600,&quot;container&quot;:null,&quot;healthChecks&quot;:[],&quot;dependencies&quot;:[],&quot;upgradeStrategy&quot;:&#123;&quot;minimumHealthCapacity&quot;:1.0,&quot;maximumOverCapacity&quot;:1.0&#125;,&quot;labels&quot;:&#123;&#125;,&quot;acceptedResourceRoles&quot;:null,&quot;version&quot;:&quot;2015-11-15T11:55:42.437Z&quot;,&quot;versionInfo&quot;:&#123;&quot;lastScalingAt&quot;:&quot;2015-11-15T11:55:42.437Z&quot;,&quot;lastConfigChangeAt&quot;:&quot;2015-11-09T08:37:51.733Z&quot;&#125;,&quot;tasksStaged&quot;:0,&quot;tasksRunning&quot;:1,&quot;tasksHealthy&quot;:0,&quot;tasksUnhealthy&quot;:0,&quot;deployments&quot;:[]&#125;]&#125;[ 然后把这个没用的webapp给DELETE掉 12$ curl -X DELETE http://node1:8080/v2/apps/webapp&#123;&quot;version&quot;:&quot;2015-11-16T12:41:39.408Z&quot;,&quot;deploymentId&quot;:&quot;e8cc87f5-916b-4cab-9266-f72bb9756a56&quot;&#125; 然后把system group里的mesos-dns和sedi服务给PUT上去 12$ curl -X PUT &quot;http://node1:8080/v2/groups&quot; -d @m-shop/mesos-dns/system.json -H &quot;Content-type: application/json&quot;&#123;&quot;version&quot;:&quot;2015-11-16T13:09:13.545Z&quot;,&quot;deploymentId&quot;:&quot;98c3f565-f1fc-4162-b560-9f20ca5","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"mesos","slug":"mesos","permalink":"http://mikasa.github.io/tags/mesos/"},{"name":"docker","slug":"docker","permalink":"http://mikasa.github.io/tags/docker/"},{"name":"marathon","slug":"marathon","permalink":"http://mikasa.github.io/tags/marathon/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"使用Mesos和Marathon搭建Docker集群","slug":"浣跨敤Mesos鍜孧arathon鎼缓Docker闆嗙兢","date":"2015-11-09T09:27:14.000Z","updated":"2016-11-24T07:16:14.352Z","comments":true,"path":"2015/11/09/浣跨敤Mesos鍜孧arathon鎼缓Docker闆嗙兢/","link":"","permalink":"http://mikasa.github.io/2015/11/09/浣跨敤Mesos鍜孧arathon鎼缓Docker闆嗙兢/","excerpt":"利用Mesos，Marathon对Docker集群进行管理，保证高容错性，高拓展性。","text":"利用Mesos，Marathon对Docker集群进行管理，保证高容错性，高拓展性。 部署1.创建Master节点虚拟机执行命令 1$: vagrant init 这时候会在当前文件夹下创建文件Vagrantfile，该文件是ruby语法的虚拟机配置文件，然后我们用vim修改该文件： 1$: vim Vagrantfile 将内容修改如下： 12345678910111213141516# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(2) do |config| config.vm.box = \"bento/centos-7.1\" config.ssh.insert_key = false config.vm.define \"node1\" do |node1| node1.vm.network \"private_network\", ip: \"192.168.33.10\" node1.vm.hostname = \"node1\" end config.vm.define \"node2\" do |node2| node2.vm.network \"private_network\", ip: \"192.168.33.11\" node2.vm.hostname = \"node2\" endend 该配置会生成两个使用系统centos-7.1的节点，分别分配IP为192.168.33.10和192.168.33.11，作为我们的Master和Slave。 然后我们启动第一个节点node1: 12345678910111213141516171819202122232425$: vagrant up node1Bringing machine &apos;node1&apos; up with &apos;virtualbox&apos; provider...==&gt; node1: Checking if box &apos;bento/centos-7.1&apos; is up to date...==&gt; node1: Clearing any previously set forwarded ports...==&gt; node1: Clearing any previously set network interfaces...==&gt; node1: Preparing network interfaces based on configuration... node1: Adapter 1: nat node1: Adapter 2: hostonly==&gt; node1: Forwarding ports... node1: 22 =&gt; 2222 (adapter 1)==&gt; node1: Booting VM...==&gt; node1: Waiting for machine to boot. This may take a few minutes... node1: SSH address: 127.0.0.1:2222 node1: SSH username: vagrant node1: SSH auth method: private key node1: Warning: Connection timeout. Retrying... node1: Warning: Remote connection disconnect. Retrying...==&gt; node1: Machine booted and ready!==&gt; node1: Checking for guest additions in VM...==&gt; node1: Setting hostname...==&gt; node1: Configuring and enabling network interfaces...==&gt; node1: Mounting shared folders... node1: /vagrant =&gt; /Users/jeff/workspace/mesos/cluster==&gt; node1: Machine already provisioned. Run `vagrant provision` or use the `--provision`==&gt; node1: flag to force provisioning. Provisioners marked to run always will still run. 这样第一个节点就成功启动了，然后我们通过ssh连接到node1进行操作 12$:vagrant ssh node1[vagrant@node1 ~]$ 这样就成功创建了第一个节点。 2.下载启动Mesos和Marathon在下载Mesos和Marathon之前，需要先把hosts文件修改一下，把127.0.0.1对应的解析中的node1删除，并在最后加上node1和node2的IP，修改后的hosts可见cat后的输出 1234567[vagrant@node1 ~]$ sudo vi /etc/hosts[vagrant@node1 ~]$ cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.33.10 node1192.168.33.11 node2 然后下载mesos的仓库，再安装mesos和marathon 12[vagrant@node1 ~]$ sudo rpm -Uvh http://repos.mesosphere.com/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm[vagrant@node1 ~]$ sudo yum install mesos marathon 3.下载配置Zookeeper下载zookeeper仓库并安装Zookeeper 12[vagrant@node1 ~]$ sudo rpm -Uvh http://archive.cloudera.com/cdh4/one-click-install/redhat/6/x86_64/cloudera-cdh-4-0.x86_64.rpm[vagrant@node1 ~]$ sudo yum -y install zookeeper zookeeper-server 初始化并启动Zookeeper 123456[vagrant@node1 ~]$ sudo -u zookeeper zookeeper-server-initialize --myid=1Using myid of 1[vagrant@node1 ~]$ sudo service zookeeper-server startJMX enabled by defaultUsing config: /etc/zookeeper/conf/zoo.cfgStarting zookeeper ... STARTED 4.下载安装Docker123[vagrant@node1 ~]$ sudo yum install -y docker[vagrant@node1 ~]$ sudo chkconfig docker on[vagrant@node1 ~]$ sudo service docker start 然后告诉mesos，允许使用Docker作为Container 12[vagrant@node1 ~]$ echo &apos;docker,mesos&apos; | sudo tee /etc/mesos-slave/containerizers[vagrant@node1 ~]$ sudo service mesos-slave restart 5.启动Mesos和Marathon启动Mesos 12[vagrant@node1 ~]$ sudo service mesos-master start[vagrant@node1 ~]$ sudo service mesos-slave start 这时可以从外部访问已经启动的Mesos的GUI界面了，访问地址为192.168.33.10:5050 启动Marathon 1[vagrant@node1 ~]$ sudo service marathon start 同样可以从GUI访问Marathon了，访问地址为192.168.33.10:8080 至此，Master节点的配置就已经结束了 6.创建配置Slave节点首先启动slave节点并用ssh登录 123$: vagrant up node2$: vagrant ssh node2[vagrant@node2 ~]$ 然后修改/etc/hosts并且下载Mesos，具体过程同步骤4。 123456789[vagrant@node2 ~]$ sudo vi /etc/hosts[vagrant@node2 ~]$ cat /etc/hosts127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.33.10 node1192.168.33.11 node2[vagrant@node2 ~]$ sudo rpm -Uvh http://repos.mesosphere.com/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm[vagrant@node2 ~]$ sudo yum install mesos 编辑node2的/etc/mesos/zk文件，使得它指向node1。 123[vagrant@node2 ~]$ sudo vi /etc/mesos/zk[vagrant@node2 ~]$ cat /etc/mesos/zkzk://192.168.33.10:2181/mesos 启动Mesos（作为slave），并且关闭mesos-master服务的自动启动 123[vagrant@node2 ~]$ sudo service mesos-slave start[vagrant@node2 ~]$ sudo chkconfig mesos-slave on[vagrant@node2 ~]$ sudo chkconfig mesos-master off 安装Docker,并允许使用Docker作为容器 12345[vagrant@node2 ~]$ sudo yum install -y docker[vagrant@node2 ~]$ sudo chkconfig docker on[vagrant@node2 ~]$ sudo service docker start[vagrant@node2 ~]$ echo &apos;docker,mesos&apos; | sudo tee /etc/mesos-slave/containerizers[vagrant@node2 ~]$ sudo service mesos-slave restart 这样，slave节点的配置也结束了 6.测试我们打开Mesos的GUI界面，查看slave，可以看到现在已经有2个slave节点了，如下图。 然后我们创建一个简单的webapp，使用python -m SimpleHTTPServer 然后将webapp应用scale到2个实例 可以看到两个实例分别在两个不同的slave中运行了 1//Todo 后面会加上部署Docker的实例测试 打包虚拟机为了之后能够快速的部署，我们可以将node1和node2分别打包成mesos-master和mesos-slave，以便于增加节点。 退出ssh，首先将node1打包为mesos-master，在宿主机上执行： 123$: vagrant package node1$: vagrant box add mesos-master package.box$: vagrant destroy node1 同样对node2我们也将其打包为mesos-slave 123$: vagrant package node2$: vagrant box add mesos-slave package.box$: vagrant destroy node2 然后修改Vagrantfile，将其修改为： 1234567891011121314151617# -*- mode: ruby -*-# vi: set ft=ruby :Vagrant.configure(2) do |config| config.vm.box = &quot;bento/centos-7.1&quot; config.ssh.insert_key = false config.vm.define &quot;node1&quot; do |node1| node1.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot; node1.vm.hostname = &quot;node1&quot; node1.vm.box = &quot;mesos-master&quot; end config.vm.define &quot;node2&quot; do |node2| node2.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.11&quot; node2.vm.hostname = &quot;node2&quot; endend 这样就完成了虚拟机的打包，然后分别运行： 12$: vagrant up node1$: vagrant up node2 就可以运行了，修改集群的slave数量，则可以直接修改Vagrantfile即可！","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"mesos","slug":"mesos","permalink":"http://mikasa.github.io/tags/mesos/"},{"name":"docker","slug":"docker","permalink":"http://mikasa.github.io/tags/docker/"},{"name":"marathon","slug":"marathon","permalink":"http://mikasa.github.io/tags/marathon/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"Mesos Framework解析","slug":"Mesos-Framework瑙ｆ瀽","date":"2015-11-07T02:53:58.000Z","updated":"2016-11-24T07:16:14.072Z","comments":true,"path":"2015/11/07/Mesos-Framework瑙ｆ瀽/","link":"","permalink":"http://mikasa.github.io/2015/11/07/Mesos-Framework瑙ｆ瀽/","excerpt":"Mesos Framework 解析介绍MesosMesos是Apache旗下的开源集群资源计算框架，它能将多台机器（包括物理机和虚拟机）的资源，包括CPU，内存，硬盘等计算资源抽象出来，进行资源隔离和共享，构建高容错性、高可用性的分布式资源管理系统。","text":"Mesos Framework 解析介绍MesosMesos是Apache旗下的开源集群资源计算框架，它能将多台机器（包括物理机和虚拟机）的资源，包括CPU，内存，硬盘等计算资源抽象出来，进行资源隔离和共享，构建高容错性、高可用性的分布式资源管理系统。 Mesos FrameworkMesos采用两层架构，所有计算框架均在底层，即Mesos Master负责对任务的资源分配给各个框架；在计算框架之上为Mesos Framework，它可用是通用的框架，也可用为特定软件编写的框架，如Framework一个长时间运行的服务（比如JobTracker等），也可以是一个短生命周期的Job或者Application。这样设计的好处是，作为底层的Mesos不需要知道顶层的应用的细节，只负责根据slave资源状况提供offers，而调度由顶层的Framework进行实现，这样底层的Mesos对所有应用（分布式or集中式，长时间服务or短暂性任务等）均可适用。 Framework可以根据是否符合任务对资源的约束，选择接受或拒绝资源邀约。一旦资源邀约被接受，Framework将与Master协作调度任务，并在数据中心的相应Slave节点上运行任务。 Framework包含两大部分： Scheduler Scheduler负责管理框架所获得的资源，按照作业的输入量，将其分解成若干任务，并未这些任务申请资源，监控这些任务的运行状态，一旦发现某个任务运行失败则重新为其申请资源。 Executor Executor负责执行调度器所分配的任务。 Framework结构如图： 分析Framework任务分配过程Framework任务分配流程图如下： Mesos的资源分配行为发生在：新框架注册，框架注销，增加节点，出现空闲资源等情况，对Mesos Framework进行资源分配的流程如下： Mesos Master中的Allocator模块将要为某个Framework分配资源，则将资源封装到ResourceOffersMessage中，通过网络传输发送给SchedulerProcess SchedulerProcess调用用户在Scheduler中编写的resourceOffers函数，告知有新资源可用； Framework的Scheduler调用MesosSchedulerDriver中的launchTasks()函数，告知将要启动的任务； Mesos Master将待启动的任务分装成RunTaskMessage发送给各个Mesos Slave； Mesos Slave收到RunTaskMessage消息后，将其发送给对应的ExecutorProcess； ExecutorProcess收到消息后，进行资源本地化，并准备任务环境，最终调度用户编写的Exector中的launchTask任务启动任务。 Framework开放接口及作用Mesos向开发者开放了API，API隐藏了Mesos底层和分布式交互的具体的细节，使得开发者可方便地用根据相应使用环境编写对应的Framework，提供的接口支持C++，Go，Haskell，Java，Python，和Scala语言。 Scheduler API 方法 说明 registered() 当Scheduler成功向Master注册时被调用 reregistered() 当Scheduler再次注册成功时被调用 disconnected() 当Scheduler和Master失去连接时被调用 resourcesOffers() 当Framework收到Mesos提供的资源时被调用 offerRescinded() 当某个offer不再适用时调用(Slave丢失或者其他Framework正在适用这个offer),master撤销发送给Framework的资源 statusUpdate() 当Mesos向框架发送消息时被调用 frameworkMessage() 用来向Scheduler传递Executor发送的消息 slaveLost() 通知Mesos无法和指定ID的slave通信 executorLost() 通知Scheduler指定的Executor已经以某个状态结束了 error() 当Scheduler出现可恢复的错误时被调用 其中最重要的为resourceOffers(SchedulerDriver, List&lt;Offer&gt;)方法。Master向Framework提供资源offer，每一份资源offer包含从某个slave上获取的资源列表（包括CPU，内存，硬盘等）。开发者重写该方法，可用根据特定的情况接受资源offer，并利用offersId交给Executor启动任务，或者拒绝该offer。一个offer会提供给多个Framework，但是第一个使用offer启动任务的Framework会获胜，其他的Framework将受到offerRescinded()发出的消息。 Scheduler API 方法 说明 registered() 当Executor驱动成功和Mesos连接上时调用 reregistered() 当Executor再次向某个重启的slave注册时调用 disconnected() 当Executor和slave失去连接时调用 launchTask() 当Executor启动某个任务时调用 killTask() 当Executor杀死某个task时被调用 frameworkMessage() 当Framework的信息到达Executor时被调用 shutdown() 当Executor需要终止所有task时被调用 error() 当Scheduler出现不可恢复的错误时被调用 同样，Executor中最核心的方法是launchTask(ExecutorDriver, TaskInfo)。可重写该方法实现执行任务，任务将在offer来源的slave上执行。执行任务在方法调用时会被阻塞，在回调完成前，该Executor无法执行其他的任务。因此如果要执行一个长时间的任务（如Web应用)，可用把任务放在线程里，通过线程的方式启动。 Framework实例分析Mesos上已有许多Framework，包括支持MPI，Hadoop，Spark，Storm等应用的。这里主要利用简单的Framework分析如何实现一个Framework。 mesos-hydra，MPI Framework，该Framework是利用python进行的实现。 RENDLER,一个利用Mesos框架实现的分布式爬虫 1填坑，待看完全部代码后补上源码分析 Framework设计模式从现有的Mesos Framework分配调度使用资源的方式中，可用总结出以下几种模式。 用于协调资源：设计的Framework作为其他Framework的资源协调者，作为服务运行，如Mesos-DNS。 基于负载状况：设计的Framework根据负载来调节资源使用，如Marathon和Aurora，会根据约定自动进行扩容和缩容。 基于预留的框架：这里主要指，某些分布式应用，在设计时已经预留了资源调度的接口，如Hadoop，Spark，Storm，因此只要实现接口，就可以将应用从原有的调度框架（如Hadoop原有框架为YARN)移植到Mesos上来。","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"Mesos","slug":"Mesos","permalink":"http://mikasa.github.io/tags/Mesos/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"源码编译安装Ambari","slug":"婧愮爜缂栬瘧瀹夎Ambari","date":"2015-10-22T05:18:06.000Z","updated":"2016-11-24T07:16:14.462Z","comments":true,"path":"2015/10/22/婧愮爜缂栬瘧瀹夎Ambari/","link":"","permalink":"http://mikasa.github.io/2015/10/22/婧愮爜缂栬瘧瀹夎Ambari/","excerpt":"源码编译安装Ambari 为什么笔者用源码编译的原因很简单，hortonworks的源太不稳定了，自己的几台Ubuntu的机子添加源后无法下载，且CentOS的机子添加源后无法下载ambari-agent，只能另辟蹊径使用源码编译","text":"源码编译安装Ambari 为什么笔者用源码编译的原因很简单，hortonworks的源太不稳定了，自己的几台Ubuntu的机子添加源后无法下载，且CentOS的机子添加源后无法下载ambari-agent，只能另辟蹊径使用源码编译 环境准备源码编译需要以下环境，需要提前安装： JDK Maven Python 2.6+ rpm-build g++,gcc,make等 NodeJS Brunch 因此需要先配置环境 安装JDK可以使用系统(CentOS)自带的openjdk，或者下载Oracle的JDK。安装后配置环境12345678[root@cloud01 ~]# vim /etc/profile# 在末尾添加 export JAVA_HOME=你的java地址# 在末尾添加 export path=$path:$JAVA_HOME/bin[root@cloud01 ~]# source /etc/profile[root@cloud01 ~]# java -versionjava version &quot;1.7.0_51&quot;Java(TM) SE Runtime Environment (build 1.7.0_51-b13)Java HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode) 如果java -version正常，则JDK安装成功 安装Maven 官网下载maven对应版本 解压 1[root@cloud01 ~]# tar -zxvf apache-maven-3.0.3-bin.tar.gz 设置环境变量 1234567891011[root@cloud01 ~]# vim /etc/profile#末尾添加 export MAVEN_HOME=你的maven地址#末尾添加 export path=$path:$MAVEN_HOME/bin[root@cloud01 ~]# source /etc/profile[root@cloud01 ~]# mvn -vApache Maven 3.0.3Maven home: /usr/local/apache-maven-3.0.3Java version: 1.7.0_51, vendor: Oracle CorporationJava home: /usr/local/jdk1.7.0_51/jreDefault locale: en_US, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;2.6.32-358.el6.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; 若 mvn -v正常，则maven安装成功 安装PythonCentOS自带Python，且CentOS6.5自带Python2.6，可以直接使用若版本过低或者未安装则执行1[root@cloud01 ~]# yum install python 安装rpm-build 检测rpm-build是否已经安装 1[root@cloud01 ~]# rpm -qa | grep rpm-build 若未安装，执行 1[root@cloud01 ~]# yum install rpm-build 安装g++等依赖执行1[root@cloud01 ~]# yum -y install gcc make gcc-c++ openssl-devel wget 安装NodeJS 下载源码及解压 12[root@cloud01 ~]# wget http://nodejs.org/dist/v0.10.26/node-v0.10.26.tar.gz[root@cloud01 ~]# tar -zvxf node-v0.10.26.tar.gz 编译及安装 123[root@cloud01 ~]# cd node-v0.10.26[root@cloud01 ~]# ./configuration[root@cloud01 ~]# make &amp;&amp; make install 验证安装配置是否成功 1node -v 编译 下载并解压源码 123[root@cloud01 ~]# wget http://www.apache.org/dist/ambari/ambari-2.1.2/apache-ambari-2.1.2-src.tar.gz[root@cloud01 ~]# tar xfvz apache-ambari-2.1.2-src.tar.gz[root@cloud01 ~]# cd apache-ambari-2.1.2-src 编译 12345[root@cloud01 ~]# mvn versions:set -DnewVersion=2.1.2[root@cloud01 ~]# pushd ambari-metrics[root@cloud01 ~]# mvn versions:set -DnewVersion=2.1.2[root@cloud01 ~]# popd[root@cloud01 ~]# mvn -B clean install package rpm:rpm -DnewVersion=2.1.2 -DskipTests -Dpython.ver=&quot;python &gt;= 2.6&quot; 安装rpm 1[root@cloud01 ~]# yum install ambari-server*.rpm 错误总结 出现异常：ClassNotFoundException: org.slf4j.helpers.MarkerIgnoringBase 使用低于Maven 3.3.3的版本，我用的是Maven 3.0.5 node-gyp rebuilt卡住原因是node-gyp rebuilt 会去下载源码rebuilt生成头文件，而国外的npm源非常慢，所以可以手动修改执行： 12npm install node-gyp node-gyp install --dist-url http://npm.taobao.org/mirrors/node 或者直接修改： 123456789101112# 获得 nodejs 版本号NODE_VERSION=`node -v | cut -d&apos;v&apos; -f 2`# 下载源码包wget http://npm.taobao.org/mirrors/node/v$NODE_VERSION/node-v$NODE_VERSION.tar.gz# 删除现有内容不完整的目录rm -rf ~/.node-gypmkdir ~/.node-gyp# 解压缩并重命名到正确格式tar zxf node-v$NODE_VERSION.tar.gz -C ~/.node-gypmv ~/.node-gyp/node-v$NODE_VERSION ~/.node-gyp/$NODE_VERSION# 创建一个标记文件printf &quot;9\\n&quot;&gt;~/.node-gyp/$NODE_VERSION/installVersion","categories":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}],"tags":[{"name":"ambari,hadoop","slug":"ambari-hadoop","permalink":"http://mikasa.github.io/tags/ambari-hadoop/"}],"keywords":[{"name":"基础架构","slug":"基础架构","permalink":"http://mikasa.github.io/categories/基础架构/"}]},{"title":"Ambari搭建Hadoop管理平台","slug":"Ambari鎼缓Hadoop绠＄悊骞冲彴","date":"2015-10-19T02:32:15.000Z","updated":"2016-11-24T07:16:13.853Z","comments":true,"path":"2015/10/19/Ambari鎼缓Hadoop绠＄悊骞冲彴/","link":"","permalink":"http://mikasa.github.io/2015/10/19/Ambari鎼缓Hadoop绠＄悊骞冲彴/","excerpt":"介绍Apache Ambari项目的目标是通过配置、管理、监控Hadoop集群，使得Hadoop集群的管理更加简单。Ambari提供了直观易用、基于Restful APIs的Web UI。","text":"介绍Apache Ambari项目的目标是通过配置、管理、监控Hadoop集群，使得Hadoop集群的管理更加简单。Ambari提供了直观易用、基于Restful APIs的Web UI。Ambari使得系统管理员可以： 配置Hadoop集群 Ambari提供了逐步安装Hadoop服务的向导 Ambari处理了Hadoop集群中复杂的配置 管理Hadoop集群 Ambari对整个Hadoop集群提供了中心管理服务，可以进行Hadoop的启动、终止和重新配置。 监控Hadoop集群 Ambari提供了监控Hadoop集群健康和状态的控制台 Ambari使用Ambari Metrics System进行各项指标的收集 Ambari使用Ambari Alert Framework进行系统报警（当节点宕机或者剩余空间不足等） 安装Ambari(Ubuntu 14.04)step1: 从服务器下载Ambari12cd /etc/apt/sources.list.dwget http://public-repo-1.hortonworks.com/ambari/ubuntu14/2.x/updates/2.1.2/ambari.list step2: 安装、启动Ambari Server从Ambari仓库下载Ambari Server：123apt-key adv --recv-keys --keyserver keyserver.ubuntu.com B9733A7A07513CADapt-get updateapt-get install ambari-server 执行命令配置Ambari Server, Database, JDK, LDAP，和其他配置项：1ambari-server setup 启动 Ambari Server：1ambari-server start step3: 使用Ambari Web UI浏览器打开地址http://&lt;ambari-server-host&gt;:8080使用账号admin和密码admin进行登录 配置环境配置mysql数据库12345mysql -u root -pmysql&gt; create database ambari;mysql&gt; use ambari;Database changedmysql&gt;source /var/lib/ambari-server/resources/Ambari-DDL-MySQL-CREATE.sql 设置ambari-server1ambari-server setup 过程中会要求配置运行用户、JDK、数据库等内容 启动ambari-server1ambari-server start 若启动失败，可以查看/var/log/ambari-server/ambari-ser.out对于以下错误： com.mysql.jdbc.exceptions.jdbc4.Communicationsxception: Communications link failure 可以采取以下方法：1234vim /etc/mysql/my.cnf# 将bind-address: 127.0.0.1 改为 bind-address: 0.0.0.0/etc/init.d/mysql restartambari-server restart","categories":[{"name":"分布式计算","slug":"分布式计算","permalink":"http://mikasa.github.io/categories/分布式计算/"}],"tags":[{"name":"ambari","slug":"ambari","permalink":"http://mikasa.github.io/tags/ambari/"},{"name":"hadoop","slug":"hadoop","permalink":"http://mikasa.github.io/tags/hadoop/"}],"keywords":[{"name":"分布式计算","slug":"分布式计算","permalink":"http://mikasa.github.io/categories/分布式计算/"}]},{"title":"2015 ACM 长春赛区网赛题解 （部分）","slug":"2015-ACM-闀挎槬璧涘尯缃戣禌棰樿В-锛堥儴鍒嗭級","date":"2015-09-14T02:16:00.000Z","updated":"2016-11-24T07:16:13.838Z","comments":true,"path":"2015/09/14/2015-ACM-闀挎槬璧涘尯缃戣禌棰樿В-锛堥儴鍒嗭級/","link":"","permalink":"http://mikasa.github.io/2015/09/14/2015-ACM-闀挎槬璧涘尯缃戣禌棰樿В-锛堥儴鍒嗭級/","excerpt":"1001 Alisha’s Party (优先队列）题目链接 HDOJ-5437题意Alisha开party, 到了的好友在门外等候，Alisha会开m次门，每次开门按给定的条件(t,p)-&gt;在第t个好友到达时候开门，并且放进p个人，若门外等候的人少于p个，则会全部放进来；最后会开一次门把所有人放进来；每次放进的p个人，按礼品价值高低顺序进入；得到一个好友进入的序列，最后求序列中的某几个序号对应的人名。","text":"1001 Alisha’s Party (优先队列）题目链接 HDOJ-5437题意Alisha开party, 到了的好友在门外等候，Alisha会开m次门，每次开门按给定的条件(t,p)-&gt;在第t个好友到达时候开门，并且放进p个人，若门外等候的人少于p个，则会全部放进来；最后会开一次门把所有人放进来；每次放进的p个人，按礼品价值高低顺序进入；得到一个好友进入的序列，最后求序列中的某几个序号对应的人名。 思路首先将所有的开门条件按时间排好序，然后用优先队列处理门外排队的人，循环模拟每个人到达的时间(i从1到k，第i时间时i-1号好友到达），将开门的计数器cnt置为0，然后当i等于某个开门条件时（即i == open[k].t)，将open[k].p个人出队并将他们的名字加入结果(vector)中。处理完所有的开门条件后，将队列中所有元素弹出，并加到结果中。 然后是这题的trick吧： 优先队列中，如果礼物价值相同，按时间顺序先进先出 m个开门条件(t,p)不一定是按顺序给的，要自行排序 所有m个开门条件结束以后，Alisha会开一次门把所有人放进去，也就是说当m=0(不开门)的时候，所有人按礼物价值降序进入 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define maxn 150005 struct node&#123; char name[205]; int w, t; friend bool operator &lt;(node a,node b) &#123; if(a.w == b.w) return a.t &gt; b.t; return a.w &lt; b.w; &#125; &#125;;node fri[maxn];struct node1&#123; int t,p;&#125;open[maxn];bool cmp(node1 a, node1 b)&#123; return a.t &lt; b.t; &#125; int main()&#123; int t, k, m, query; //freopen(\"in.txt\",\"r\",stdin); scanf(\"%d\", &amp;t); while(t--) &#123; scanf(\"%d%d%d\", &amp;k, &amp;m, &amp;query); for(int i = 0 ; i &lt; k; i++)&#123; scanf(\"%s %d\",fri[i].name,&amp;fri[i].w); fri[i].t = i; &#125; open[0].t = -1; for(int i = 0;i &lt; m;i++) scanf(\"%d%d\", &amp;open[i].t, &amp;open[i].p); priority_queue&lt;node&gt;q; vector&lt;int&gt; ans; sort(open, open + m, cmp); int cnt = 0; for(int i = 1 ; i &lt;= k; i++)&#123; q.push(fri[i-1]); if(i == open[cnt].t)&#123; //cout&lt;&lt;i&lt;&lt;endl; for(int j = 1; j &lt;= open[cnt].p &amp;&amp; (!q.empty()); j++)&#123; node tmp = q.top(); //cout&lt;&lt;tmp.name&lt;&lt;endl; q.pop(); ans.push_back(tmp.t); &#125; cnt++; &#125; &#125; while(!q.empty())&#123; node tmp = q.top(); q.pop(); ans.push_back(tmp.t); &#125; int len = ans.size(); for(int i = 0; i &lt; query; i++)&#123; int x; scanf(\"%d\",&amp;x); printf(\"%s\", fri[ans[x-1]].name); if(i == query-1) printf(\"\\n\"); else printf(\" \"); &#125; &#125;&#125; 1002 Ponds (DFS）题目链接 HDOJ-5438题意给定一个无向图，首先去掉度数小于2的顶点（是不断删去，删去一个顶点可能会再次出现需要删除的顶点，要删到直到不再出现为止)，然后对剩下的图计算其每个连通分量的顶点数，若顶点数为奇数，则将其权值加到最后的结果，输出到最后的结果。 trick:需要不断删去不符合节点直到不存在不符合节点为止，如下图情况：图1中所有顶点都会被去掉，图2中只剩下1,2,3 思路首先用队列处理删点操作，先将所有符合删除条件的点入队，然后从队列中每弹出一个顶点，将其所有相邻顶点度数-1，若再次出现符合删除条件，则将新点也入队，直到队列为空。（注意用访问标记减少重复访问）；然后用DFS去遍历整个图，每访问完一个连通子图计算权值和并判断节点数。 复杂度O(|V|) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define LL long longconst int maxn = 10010;vector &lt;int&gt; g[maxn];LL w[maxn];int vis[maxn];int deg[maxn];LL ans = 0;LL sum = 0;int cnt = 0;void dfs(int x)&#123; if(vis[x]) return; vis[x] = 1; int len = g[x].size(); // cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;cnt&lt;&lt;endl; sum += w[x]; cnt++; for(int i = 0; i &lt; len; i++)&#123; int v = g[x][i]; if(!vis[v])&#123; dfs(v); &#125; &#125;&#125;void work(int n)&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123; if(deg[i] &lt; 2)&#123; vis[i] = 1; q.push(i); &#125; &#125; while(!q.empty())&#123; int u = q.front(); q.pop(); int len = g[u].size(); for(int i = 0 ; i &lt; len; i++)&#123; int v = g[u][i]; if(!vis[v])&#123; deg[v] --; if(deg[v] &lt; 2)&#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; int n,m; memset(vis, 0 , sizeof(vis)); memset(deg,0, sizeof(deg)); memset(g,0, sizeof(g)); ans = 0; scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) scanf(\"%lld\",w+i); for(int i = 1; i &lt;= m; i++)&#123; int u,v; scanf(\"%d%d\",&amp;u,&amp;v); g[u].push_back(v); g[v].push_back(u); deg[u]++; deg[v]++; &#125; work(n); // for(int i = 1; i &lt;= n; i++) // cout&lt;&lt;vis[i]&lt;&lt;\" \"; // cout&lt;&lt;endl; for(int i = 1; i &lt;= n; i++)&#123; if(!vis[i])&#123; cnt = 0; sum = 0; dfs(i); if(cnt%2 == 1) ans += sum; &#125; &#125; printf(\"%lld\\n\",ans); &#125;&#125; 1005 Travel(并查集） 题目链接 HDOJ-5441之前没有做过并查集处理图的题目，该题之后上题解 1006 Favorite Donut（后缀数组）题目链接 HDOJ-5442这题据说比较裸的后缀自动机，之后上题解 1007 The Water Problem (水题）题目链接 HDOJ-5443签到题，没什么好说的，区间最大值，不需要RMQ，线段树什么的，直接O(nq）就能过，很好的手速题，5min看完题8min交题ORZ~ 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 1005;int a[maxn];int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; int n; scanf(\"%d\",&amp;n); for(int i = 1 ; i &lt;= n; i++) scanf(\"%d\",a+i); int q; scanf(\"%d\",&amp;q); for(int i = 1 ; i &lt;= q; i++)&#123; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); int max = -1; for(int j = l; j&lt;=r; j++)&#123; if(a[j] &gt; max ) max = a[j]; &#125; printf(\"%d\\n\",max); &#125; &#125;&#125; 1008 Elven Postman (二叉排序树）题目链接 HDOJ-5444题意题目描述了一种房间的排序方式，又讲了给定的序列怎么来的，讲了一大堆，结果发现这树就是一颗倒着的二叉排序树（二叉搜索树），大的数放左节点，小的树放右节点。 思路给定一个序列可以构造出一颗BST，然后根据查询条件去查找就行了，向左递归输出W，向右递归输出E。 复杂度：查询O(log(q)) trick:按题意，给定的序列长度是1000，也就是说树的深度是1000，若用数组模拟，需要2^1000大小的数组，必然RE，因此要用指针做。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt; using namespace std; bool first; struct BST&#123; int data; BST *leftchild; BST *rightchild; &#125;; void Build(BST *&amp;root,int x)&#123; if(root==NULL)&#123; root=(BST *)malloc(sizeof(BST)); root-&gt;data=x; root-&gt;leftchild=root-&gt;rightchild=NULL; &#125;else &#123; if(x&lt;root-&gt;data)&#123; Build(root-&gt;leftchild,x); &#125;else Build(root-&gt;rightchild,x); &#125; &#125; void Search(int v,BST *root)&#123; if(root == NULL)&#123; return; &#125;else if(root-&gt;data &gt; v)&#123; printf(\"E\"); Search(v, root-&gt;leftchild); &#125;else if(root-&gt;data &lt;v)&#123; printf(\"W\"); Search(v, root-&gt;rightchild); &#125;else&#123; return; &#125; &#125; int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; BST *root=NULL; int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int x; scanf(\"%d\",&amp;x); Build(root,x); &#125; int q; scanf(\"%d\",&amp;q); for(int i = 0; i &lt; q; i++)&#123; int t; scanf(\"%d\",&amp;t); Search(t,root); printf(\"\\n\"); &#125; &#125;&#125; 1010 Unknown Treasure(Lucas定理+中国剩余定理+按位乘法)题目链接 HDOJ-5446题意组合数取模，求C(n,m)mod(p1p2…pk) 思路先使用Lucas定理求出对于每个pi，C(n, m) % pi的值。再使用中国剩余定理对模数和余数求解即可。 trick:在用中国剩余定理的过程中，会出现long long * long long 结果爆掉了的情况，这个是导致WA的问题。。所以要手写一个按位乘法 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;using namespace std;long long n,m,k;long long lcm;long long remainer[20];long long divider[20];long long extend_gcd(long long a,long long b,long long &amp;x,long long &amp;y)&#123; if (a==0 &amp;&amp; b==0) return -1; if (b==0) &#123; x=1; y=0; return a; &#125; long long ans=extend_gcd(b,a%b,x,y); long long temp=x; x=y; y=temp-a/b*y; return ans;&#125;long long mod_reverse(long long a,long long d_p)&#123; long long x,y; long long ans=extend_gcd(a,d_p,x,y); if (ans!=1) return -1; else return (x%d_p+d_p)%d_p;&#125;long long mul(long long a, long long b, long long mod) &#123; a = (a % mod + mod) % mod; b = (b % mod + mod) % mod; long long ret = 0; while(b)&#123; if(b&amp;1)&#123; ret += a; if(ret &gt;= mod) ret -= mod; &#125; b &gt;&gt;= 1; a &lt;&lt;= 1; if(a &gt;= mod) a -= mod; &#125; return ret; &#125; long long crt(long long lcm)&#123; long long ans=0; for (long long i=0;i&lt;k;i++) &#123; long long others; others=lcm/divider[i]; long long mr=mod_reverse(others,divider[i]); //ans = (ans+remainer[i]*others*mr)%lcm; ans = (ans + mul(mul(remainer[i],others,lcm),mr,lcm)); &#125; return (ans+lcm)%lcm;&#125;long long mod_pow(long long a,long long n_,long long p)&#123; long long ret=1; long long A=a; while(n_) &#123; if (n_ &amp; 1) ret=(ret*A)%p; A=(A*A)%p; n_&gt;&gt;=1; &#125; return ret;&#125;long long factorial[100010];void init(long long p)&#123; factorial[0] = 1; for(long long i = 1;i &lt;= p;i++) factorial[i] = factorial[i-1]*i%p;&#125;long long Lucas(long long a,long long k_,long long p)&#123; long long re = 1; while(a &amp;&amp; k_) &#123; long long aa = a%p; long long bb = k_%p; if(aa &lt; bb) return 0; re = re*factorial[aa]*mod_pow(factorial[bb]*factorial[aa-bb]%p,p-2,p)%p; a /= p; k_ /= p; &#125; return re;&#125;int main()&#123; int T; //freopen(\"in.txt\",\"r\",stdin); long long p; cin&gt;&gt;T; while(T--) &#123; lcm = 1; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for (long long i=0;i&lt;k;i++) &#123; cin&gt;&gt;p; init(p); divider[i] = p; lcm = lcm*divider[i]; remainer[i] = Lucas(n,m,p); &#125; cout&lt;&lt;crt(lcm)&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://mikasa.github.io/tags/数论/"},{"name":"dfs","slug":"dfs","permalink":"http://mikasa.github.io/tags/dfs/"},{"name":"并查集","slug":"并查集","permalink":"http://mikasa.github.io/tags/并查集/"},{"name":"图论","slug":"图论","permalink":"http://mikasa.github.io/tags/图论/"},{"name":"lucas定理","slug":"lucas定理","permalink":"http://mikasa.github.io/tags/lucas定理/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://mikasa.github.io/tags/中国剩余定理/"},{"name":"优先队列","slug":"优先队列","permalink":"http://mikasa.github.io/tags/优先队列/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://mikasa.github.io/tags/后缀数组/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"hdu 5392 Infoplane in Tina Town","slug":"hdu-5392-Infoplane-in-Tina-Town","date":"2015-09-04T03:01:28.000Z","updated":"2016-11-24T07:16:14.290Z","comments":true,"path":"2015/09/04/hdu-5392-Infoplane-in-Tina-Town/","link":"","permalink":"http://mikasa.github.io/2015/09/04/hdu-5392-Infoplane-in-Tina-Town/","excerpt":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5392 题意给定一个置换a，求序列1-n经过多少次a置换能够再次变回序列1-n 分析题意很明显，是求置换群的循环长度。 根据数论中的内容，循环长度等于所有循环节长度的最小公倍数，因此只要计算所有循环节的长度即可。 但是题目中提到需要对最后的答案进行求模处理，然而欧几里得算法求最小公倍数无法去模，因此要用质因数分解法进行求最小公倍数","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5392 题意给定一个置换a，求序列1-n经过多少次a置换能够再次变回序列1-n 分析题意很明显，是求置换群的循环长度。 根据数论中的内容，循环长度等于所有循环节长度的最小公倍数，因此只要计算所有循环节的长度即可。 但是题目中提到需要对最后的答案进行求模处理，然而欧几里得算法求最小公倍数无法去模，因此要用质因数分解法进行求最小公倍数复杂度：O(nlog(n)) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int maxn = 3000010;const LL mod = 3221225473;int a[maxn];int b[maxn];int vis[maxn];int n;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--)&#123; scanf(\"%d\",&amp;n); memset(vis,0,sizeof(vis)); memset(b,0,sizeof(b)); for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\",a+i); &#125; for(int i = 1 ; i &lt;= n; i++)&#123; if(vis[i]) continue; int k = i; int len = 0; while(!vis[k])&#123; vis[k] = 1; len++; k = a[k]; &#125; for(int j = 2; j*j &lt;= len; j++)&#123; int cnt = 0; while(len % j == 0)&#123; cnt++; len /= j; &#125; b[j] = max(b[j], cnt); &#125; if(len &gt; 1) b[len] = max(b[len], 1); &#125; LL ans = 1; for(int i = 2; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= b[i]; j++) ans = ans * i % mod; &#125; printf(\"%lld\\n\",ans); &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://mikasa.github.io/tags/数论/"},{"name":"最小公倍数","slug":"最小公倍数","permalink":"http://mikasa.github.io/tags/最小公倍数/"},{"name":"群论","slug":"群论","permalink":"http://mikasa.github.io/tags/群论/"},{"name":"循环节","slug":"循环节","permalink":"http://mikasa.github.io/tags/循环节/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"求多个数的最小公倍数lcm","slug":"姹傚涓暟鐨勬渶灏忓叕鍊嶆暟lcm","date":"2015-09-04T02:21:00.000Z","updated":"2016-11-24T07:16:14.446Z","comments":true,"path":"2015/09/04/姹傚涓暟鐨勬渶灏忓叕鍊嶆暟lcm/","link":"","permalink":"http://mikasa.github.io/2015/09/04/姹傚涓暟鐨勬渶灏忓叕鍊嶆暟lcm/","excerpt":"欧几里得法由公式lcm(a,b) = a*b/gcd(a,b)可以得到两个数的lcm，同时多个数的最小公倍数可以先求前两个数的最小公倍数，再和第三个数求最小公倍数，以此类推。","text":"欧几里得法由公式lcm(a,b) = a*b/gcd(a,b)可以得到两个数的lcm，同时多个数的最小公倍数可以先求前两个数的最小公倍数，再和第三个数求最小公倍数，以此类推。 复杂度O(nlog(n)) 代码12345678910111213int gcd(int a, int b)&#123; return b == 0? a : gcd(b, a%b); &#125;int lcm(int x, int y)&#123; return x*y/gcd(x,y);&#125; int lcm2(int n)&#123; int ret = 1; for(int i = 0; i &lt; n; i++)&#123; ret = lcm(ret, a[i]); &#125; return ret;&#125; 分解质因数法将每个数分解成质因数p的幂次的乘积的形式，则每个质因数在lcm中出现的次数为在每个a[i]中出现次数的最大值，统计每个质因数p出现的次数，最后做一次乘积即可。 1lcm = p_&#123;1&#125;^&#123;b_&#123;1&#125;&#125;\\times p_&#123;2&#125;^&#123;b_&#123;2&#125;&#125;\\times p_&#123;3&#125;^&#123;b_&#123;3&#125;&#125;\\times ... p_&#123;k&#125;^&#123;b_&#123;k&#125;&#125; 复杂度O(nlog(n)) 代码123456789101112131415161718192021int lcm1(int n)&#123; for(int i = 0 ; i &lt; n; i++)&#123; for(int j = 2; j * j &lt;= a[i]; j++)&#123; int cnt = 0; while(a[i] % j == 0)&#123; cnt ++; a[i] /= j; &#125; b[j] = max(b[j], cnt); &#125; if(a[i] &gt; 1)&#123; b[a[i]] = max(b[a[i]], 1); &#125; &#125; int ret = 1; for(int i = 2; i &lt; 10000; i++)&#123; for(int j = 1; j &lt;= b[i]; j++) ret = ret * i % mod; &#125; return ret;&#125;","categories":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://mikasa.github.io/tags/数论/"},{"name":"最小公倍数","slug":"最小公倍数","permalink":"http://mikasa.github.io/tags/最小公倍数/"}],"keywords":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}]},{"title":"大数乘法逆元求法总结","slug":"澶ф暟涔樻硶閫嗗厓姹傛硶鎬荤粨","date":"2015-09-01T02:46:00.000Z","updated":"2016-11-24T07:16:14.415Z","comments":true,"path":"2015/09/01/澶ф暟涔樻硶閫嗗厓姹傛硶鎬荤粨/","link":"","permalink":"http://mikasa.github.io/2015/09/01/澶ф暟涔樻硶閫嗗厓姹傛硶鎬荤粨/","excerpt":"大数的乘法逆元","text":"大数的乘法逆元 暴力法 12int i; for (i=1;;i++) &#123; if (((long long int)(n)*i-an)%M==0) break; &#125; 欧拉函数 1234long long inv( long long n ) &#123; return pow( n, M - 2 )%M; &#125; 拓展欧几里得算法 1234567891011121314151617181920//扩展欧几里德 void exp_gcd( LL a ,LL b,LL &amp;x,LL &amp;y) &#123; if( b == 0 ) &#123; x = 1; y = 0; &#125; else &#123; exp_gcd( b,a%b,x,y ); LL t; t = x; x = y; y = t - a/b*y; &#125; &#125; //逆元 inline LL getNN(LL x) &#123; LL now , t; exp_gcd( x, M,now,t ); return (now%M+M)%M; &#125; 拓展欧几里得（简洁版） int64 inv(int64 x) { //简洁版求逆元 if(x == 1) return 1; return inv(MOD%x) * (MOD - MOD/x) % MOD; }","categories":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://mikasa.github.io/tags/数论/"}],"keywords":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}]},{"title":"hdu 1054 Strategic Game 贪心","slug":"hdu-1054-Strategic-Game-璐績","date":"2015-07-27T08:05:00.000Z","updated":"2016-11-24T07:16:14.165Z","comments":true,"path":"2015/07/27/hdu-1054-Strategic-Game-璐績/","link":"","permalink":"http://mikasa.github.io/2015/07/27/hdu-1054-Strategic-Game-璐績/","excerpt":"","text":"题目题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1054 题意给定一个二分图（给图的方式太蛋疼，输入输出好麻烦），在任意节点放置哨兵使得可以覆盖整个图。图的节点数n &lt;= 1500 分析这题看似一道很裸的二分图最小点覆盖（或者最大匹配），然而我并不会这些内容，所以一直在想其他策略。 一开始有一种贪心思路是，将点以度数进行排序，因为取度数较大的点上放一个哨兵的收益最大，因此需要动态维护一个堆，使得这个堆堆顶始终是度数最大的点，然后从堆顶取点，并将点对应的相邻点度数一次减1，然后将度数为0的点直接踢出堆外以减小复杂度。而这个堆可以是二叉堆，修改、删除、插入、取堆顶元素的操作复杂度均为O(logn)，然而我这块儿也学得不好，直接敲模板又比较麻烦。 所以从思路二继续尝试其他思路，发现从相反反向考虑，度数较大的点放哨兵收益最大，而度数最小的点（二分图无孤立点）即度数为1的点放哨兵度数收益最小，因此从反方向考虑这个问题的话，就是尽量不要再度数为1的点上放哨兵，而是用它的邻点取代它。因此我们维护一个队列，放置所有度数为1的点，每次取出队首u，并取出第一个邻点v，将邻点v的所有邻点度数更新，若出现度数为1的点则再加入队列。 代码#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; const int maxn = 1600; int deg[maxn]; int vis[maxn]; vector&lt;int&gt; edge[maxn]; int main(){ int n; // freopen(\"in.txt\",\"r\",stdin); while(~scanf(\"%d\",&amp;n)){ memset(deg,0,sizeof(deg)); memset(vis,0,sizeof(vis)); memset(edge,0,sizeof(edge)); for(int i = 0 ; i &lt; n ; i++){ int m,u; scanf(\"%d:(%d)\",&amp;u,&amp;m); if(m &gt; 0){ for(int j = 0 ; j &lt; m; j++){ int v; scanf(\"%d\",&amp;v); edge[u].push_back(v); edge[v].push_back(u); deg[u]++; deg[v]++; } } } // for(int i = 0 ; i &lt; n; i++){ // cout&lt;&lt;deg[i]&lt;&lt;\" \"; // } // cout&lt;&lt;endl; if(n == 1){ puts(\"1\"); continue; } queue &lt;int&gt; q; for(int i = 0 ; i &lt; n; i++){ if(deg[i] == 1) q.push(i); } int ans = 0; while(!q.empty()){ int u = q.front(); q.pop(); if(vis[u]) continue; for(int i = 0; i &lt; edge[u].size(); i++){ int v = edge[u][i]; if(!vis[v]){ vis[v] = 1; ans++; //选1个放烧饼 for(int j = 0; j &lt; edge[v].size(); j++){ int w = edge[v][j]; deg[w] --; if(deg[w] == 1 &amp;&amp; !vis[w]){ q.push(w); } } break; } } } cout&lt;&lt;ans&lt;&lt;endl; } }","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"队列","slug":"队列","permalink":"http://mikasa.github.io/tags/队列/"},{"name":"贪心","slug":"贪心","permalink":"http://mikasa.github.io/tags/贪心/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"hdu 5311 Hidden String BestCoder 1st Anniversary B 暴搜","slug":"hdu-5311-Hidden-String-BestCoder-1st-Anniversary-B-鏆存悳","date":"2015-07-26T09:10:00.000Z","updated":"2016-11-24T07:16:14.274Z","comments":true,"path":"2015/07/26/hdu-5311-Hidden-String-BestCoder-1st-Anniversary-B-鏆存悳/","link":"","permalink":"http://mikasa.github.io/2015/07/26/hdu-5311-Hidden-String-BestCoder-1st-Anniversary-B-鏆存悳/","excerpt":"","text":"题目题目地址：http://acm.hdu.edu.cn/showproblem.php?pid=5311 题意指定串为”anniversary”，在输入串中找到不相交的三段，拼起来数指定串，len(s)范围为100 分析这题卡了挺久主要是题意理解问题，一直以为这三段不需要顺序拼接，例如sary1ver1anni这种应该页输出YES，然而并不是。事实上是简单的顺序拼接，这样的话可以进行最最暴力的for循环搜索了，搜索过程可以用KMP加速以下，而KMP的起始位置是动态变化的就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;void getNext(const std::string &amp;p, std::vector&lt;int&gt; &amp;next)&#123; next.resize(p.size()); next[0] = -1; int i = 0, j = -1; while (i != p.size() - 1) &#123; //这里注意，i==0的时候实际上求的是next[1]的值，以此类推 if (j == -1 || p[i] == p[j]) &#123; ++i; ++j; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125;&#125;int kmp(const std::string&amp; s, const std::string&amp; p, const int sIndex = 0)&#123; std::vector&lt;int&gt;next(p.size()); getNext(p, next);//获取next数组，保存到vector中 int i = sIndex, j = 0; while(i != s.length() &amp;&amp; j != p.length()) &#123; if (j == -1 || s[i] == p[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; return j == p.length() ? i - j: -1;&#125;string s;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; cin &gt;&gt; s; string s0 = \"anniversary\"; int len0 = s0.size(); string s1, s2, s3; bool flag = false; for (int i = 1; i &lt; len0; ++i) &#123; for (int j = i + 1; j &lt; len0; ++j) &#123; s1.clear(); s2.clear(); s3.clear(); for (int t = 0; t &lt; i; ++t) &#123; s1 += s0[t]; &#125; for (int t = i; t &lt; j; ++t) &#123; s2 += s0[t]; &#125; for (int t = j; t &lt; len0; ++t) &#123; s3 += s0[t]; &#125; // cout &lt;&lt; s1 &lt;&lt; \" \" &lt;&lt; s2 &lt;&lt; \" \" &lt;&lt; s3 &lt;&lt; endl; int idx = kmp(s, s1); if (idx == -1) &#123; continue; &#125; //printf(\"%d %d 111\\n\", i, j); idx = kmp(s, s2, idx + s1.size()); if (idx == -1) &#123; continue; &#125; //printf(\"222\\n\"); idx = kmp(s, s3, idx + s2.size()); if (idx == -1) &#123; continue; &#125; flag= true; &#125; &#125; if (flag) &#123; printf(\"YES\\n\"); &#125; else &#123; printf(\"NO\\n\"); &#125; &#125; return 0;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://mikasa.github.io/tags/搜索/"},{"name":"暴力","slug":"暴力","permalink":"http://mikasa.github.io/tags/暴力/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"基础算法训练 - 排序专题","slug":"鍩虹绠楁硶璁粌-鎺掑簭涓撻","date":"2015-07-12T02:13:00.000Z","updated":"2016-11-24T07:16:14.399Z","comments":true,"path":"2015/07/12/鍩虹绠楁硶璁粌-鎺掑簭涓撻/","link":"","permalink":"http://mikasa.github.io/2015/07/12/鍩虹绠楁硶璁粌-鎺掑簭涓撻/","excerpt":"","text":"前言以前的算法和数据结构基础不是很扎实，从现在开始，弄懂每个算法的原理，打好基础。 1.快速排序快排的核心思想是分治，核心算法则是对数组的划分： `quicksort(A,p,r): if p &lt; r q = partition(A,p,r) quicksort(A,p,q-1) quicksort(A,q+1,r)` 其中划分函数partition的核心操作是： 将数组最后一个元素A[r]作为比较对象 i = p-1 , j = p, j不停自加，判断A[r]和A[j]大小，若A[j]小于A[r]则将后游标i前进1位，并交换a[i]和a[j] 最后交换a[i+1]和a[r] 交换所得目的数将所有比a[r]小的数放在数组前面，所有比a[r]大的数放在数组后面，a[r]则在数组中间，返回数字为比a[r]小的数的个数 代码： `#include using namespace std; int a[100] = {13,19,9,5,12,8,7,4,21,2,6,11}; void swap(int &amp;x,int &amp;y){ int t = x; x = y; y = t; } int partition(int p,int r){ int i = p - 1; int j = p; for(;j &lt; r; j++){ if(a[j] &lt; a[r]){ i++; swap(a[i],a[j]); } } swap(a[r],a[i+1]); return i+1; } void quicksort(int p,int r){ if(p &lt; r){ int q = partition(p,r); quicksort(p,q-1); quicksort(q+1,r); } } int main(){ quicksort(0,11); // int n = partition(0,11); for(int i = 0 ; i &lt; 12;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; }`","categories":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://mikasa.github.io/tags/排序/"},{"name":"基础算法","slug":"基础算法","permalink":"http://mikasa.github.io/tags/基础算法/"}],"keywords":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}]},{"title":"hdu 1176 免费馅饼 变型数塔 dp","slug":"hdu-1176-鍏嶈垂棣呴ゼ-鍙樺瀷鏁板-dp","date":"2015-06-27T09:56:00.000Z","updated":"2016-11-24T07:16:14.181Z","comments":true,"path":"2015/06/27/hdu-1176-鍏嶈垂棣呴ゼ-鍙樺瀷鏁板-dp/","link":"","permalink":"http://mikasa.github.io/2015/06/27/hdu-1176-鍏嶈垂棣呴ゼ-鍙樺瀷鏁板-dp/","excerpt":"","text":"分析题目：题目链接 按题意，t时间会落下一个馅饼在x位置，而处于x’位置的gameboy只能拿到x’+1、x’、x’-1三个位置的馅饼，若将馅饼下落信息用一个数组f[t][x]，发现对于每个i，j，gameboy只能取得f[i+1][j+1]，f[i+1][j-1]，f[i+1][j]三个值，要使得最后取得的值最大，一看这是典型的数塔问题，然后就可以用dp轻松解决了 注意：由于数组每层在计算后不再使用，所以直接用原数组进行滚动，从下往上将结果累加即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long#define MP make_pair#define mod 1000000007#define eps 1e-8#define pi acos(-1.0)#define inf 0x3fffffff#define maxn 200055 int f[maxn][20]; int maxx(int a,int b,int c)&#123; return max(max(a,b),c);&#125;int main()&#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin); //freopen(\"out.txt\",\"w\",stdout); #endif int n; while(~scanf(\"%d\",&amp;n)&amp;&amp;n)&#123; int t,x; memset(f,0,sizeof(f)); int mx = 0; for(int i = 0 ; i &lt; n; i++)&#123; scanf(\"%d %d\",&amp;x,&amp;t); f[t][x+1] ++; if(t &gt; mx) mx = t; &#125; for(int i = mx -1 ; i &gt; 0; i--)&#123; for(int j = 1; j &lt;= 11;j++)&#123; f[i][j] += maxx(f[i+1][j],f[i+1][j-1],f[i+1][j+1]); &#125; &#125; printf(\"%d\\n\",maxx(f[1][5],f[1][6],f[1][7])); &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://mikasa.github.io/tags/dp/"},{"name":"数塔","slug":"数塔","permalink":"http://mikasa.github.io/tags/数塔/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"文本挖掘初步 - 文本中文分词","slug":"鏂囨湰鎸栨帢鍒濇-鏂囨湰涓枃鍒嗚瘝","date":"2015-06-05T14:32:00.000Z","updated":"2016-11-24T07:16:14.430Z","comments":true,"path":"2015/06/05/鏂囨湰鎸栨帢鍒濇-鏂囨湰涓枃鍒嗚瘝/","link":"","permalink":"http://mikasa.github.io/2015/06/05/鏂囨湰鎸栨帢鍒濇-鏂囨湰涓枃鍒嗚瘝/","excerpt":"","text":"介绍中文分词(Chinese Word Segmentation)指的是将一个汉字序列切分成一个一个单独的词。 如同编译原理中的词法分析的重要性,中文分词是文本挖掘的基础,需要通过机器自动将输入的句子切分成一个个的词语,才能进行更多的处理. 中文分词和英文分词最大的区别在于,英文单词之间是以空格作为自然分界符的，而汉语是以字为基本的书写单位，词语之间没有明显的区分标记,因此中文分词的难度比英文分词大了很多. 方法分词算法可分为三大类：基于字典、词库匹配的分词方法,基于词频度统计的分词方法和基于知识理解的分词方法。 1. 基于字典,词库(字符串匹配)的分词方法 这种方法按照一定策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行匹配，若在词典中找到某个字符串，则匹配成功。识别出一个词，根据扫描方向的不同分为正向匹配和逆向匹配。采用该方法的分词算法主要有: 正向最大匹配法（由左到右的方向） 逆向最大匹配法（由右到左的方向） 最少切分（使每一句中切出的词数最小） 2.基于词频度统计的分词方法 这是一种全切分方法。它不依靠词典,而是将文章中任意两个字同时出现的频率进行统计,次数越高的就可能是一个词。它首先切分出与词表匹配的所有可能的词,运用统计语言模型和决策算法决定最优的切分结果。它的优点在于可以发现所有的切分歧义并且容易将新词提取出来。 3.基于知识理解的分词 该方法主要基于句法、语法分析，并结合语义分析，通过对上下文内容所提供信息的分析对词进行定界，它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断。这类方法试图让机器具有人类的理解能力，需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式。因此目前基于知识的分词系统还处在试验阶段。 工具在中文分词领域,有很多已经非常成熟的分词工具可以被使用,以下对各工具的算法和效率(根据网上情报)进行总结. 1.ICTCLAS(NLPIR) http://ictclas.nlpir.org/ ICTCLAS是中国科学院计算技术研究所在多年研究基础上，耗时一年研制出了基于多层隐马模型(HMM)的汉语词法分析系统 ，功能有：中文分词；词性标注；自定义词典等。分词正确率高,分词速度快.源代码数以C++编写的,并提供JAVA接口. 速度: 单机 (996KB/s) 2.Stanford Word Segmenter || CRF++ http://nlp.stanford.edu/software/segmenter.shtml 这两个中文分词工具都是基于条件随机场CRF(Conditional Random Field)模型实现的,其基本思路是对汉字进行标注即由字构词(组词)，不仅考虑了文字词语出现的频率信息，同时考虑上下文语境，具备较好的学习能力，因此其对歧义词和未登录词的识别都具有良好的效果；其不足之处是训练周期较长，运营时计算量较大. 速度: (暂未获得) 3.Mmseg http://technology.chtsai.org/mmseg/ Mmseg是典型的基于字典的中文分词工具,其主要实现原理是基于最大匹配算法.它提供Simple和Complex两种最大匹配算法,即简单的和复杂的.简单的最大匹配算法从字符串开头开始,获取最长的匹配串;而复杂的最大匹配算法则针对存在歧义的单词,向前再看两个单词再进行判断. Mmseg支持在lucene和solr中使用,在该二者中配置Mmseg,即可对中文文本进行分词索引.这也是Mmseg被使用广泛的一个原因.同时因为其实现原理简单,效果也很不错,且提供Java支持(Mmseg4j),也是很受欢迎的一款分词工具. 速度: complex 60W字/s (1200 KB/s) ；simple 100W字/s (1900 KB/s) 4.IKAnalyzer http://code.google.com/p/ik-analyzer/downloads/list IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。采用了特有的”正向迭代最细粒度切分算法”(我还没取研究这个算法),支持细粒度和智能分词两种切分模式.同样,IKAnalyzer也提供了对Solr和Lucene的支持. 速度: IK2012 160W字/s (3000KB/s) 代码根据分词的成功率,速率以及使用接口简单,在之后的所有后续挖掘过程中将采用ICTCLAS2015作为分词器,所以需要对其进行简单的封装. JNA实现接口CLibrary: 123456789101112131415package com.jetmuffin.analyzer;import com.sun.jna.Library;public interface CLibrary extends Library&#123; public int NLPIR_Init(String sDataPath, int encoding, String sLicenceCode); public String NLPIR_ParagraphProcess(String sSrc, int bPOSTagged); public String NLPIR_GetKeyWords(String sLine, int nMaxKeyLimit, boolean bWeightOut); public String NLPIR_GetFileKeyWords(String sLine, int nMaxKeyLimit, boolean bWeightOut); public int NLPIR_AddUserWord(String sWord);//add by qp 2008.11.10 public int NLPIR_DelUsrWord(String sWord);//add by qp 2008.11.10 public int NLPIR_ImportUserDict(String sWord,boolean bOverWrite); public String NLPIR_WordFreqStat(String sWord); public String NLPIR_GetLastErrorMsg(); public void NLPIR_Exit();&#125; 接口实现类Nlpir: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.jetmuffin.analyzer;import com.sun.jna.Native;public class NLPIR &#123; public static CLibrary Instance; private String systemCharset; private String systemFolder; int charsetType; public NLPIR()&#123; systemFolder = \"/home/jeff/src/ICTCLAS2015\"; //ICTCLAS的目录,包括字典文件等 systemCharset = \"UTF-8\"; //默认字符集 charsetType = 1; Instance = (CLibrary) Native.loadLibrary( \"/home/jeff/src/ICTCLAS2015/lib/linux32/libNLPIR.so\", CLibrary.class); //ICTCLAS的so文件地址 &#125; public static CLibrary getInstance() &#123; return Instance; &#125; public static void setInstance(CLibrary instance) &#123; Instance = instance; &#125; public String getSystemCharset() &#123; return systemCharset; &#125; public void setSystemCharset(String systemCharset) &#123; this.systemCharset = systemCharset; &#125; public String getSystemFolder() &#123; return systemFolder; &#125; public void setSystemFolder(String systemFolder) &#123; this.systemFolder = systemFolder; &#125; public int getCharsetType() &#123; return charsetType; &#125; public void setCharsetType(int charsetType) &#123; this.charsetType = charsetType; &#125; &#125;&#125; 测试类: 123456789101112131415161718192021package com.jetmuffin.test;import org.junit.Test;import com.jetmuffin.NLPIR;public class TestNlpir &#123; @Test public void test()&#123; NLPIR nlpir = new NLPIR(); nlpir.Instance.NLPIR_Init(nlpir.getSystemFolder(),nlpir.getCharsetType() ,nlpir.getSystemCharset()); String nativeBytes = null; String sInput = \"什么是机器学习\"; nlpir.Instance.NLPIR_ImportUserDict(\"/home/jeff/workspace/data/dict\", false); //加载用户自定义词典 nativeBytes = nlpir.Instance.NLPIR_ParagraphProcess(sInput, 0); //分词 String[] words = nativeBytes.split(\" \"); //分词结果以空格进行分割 System.out.println(words.length); //输出分词词数 System.out.println(nativeBytes); //输出分词结果 &#125; &#125;&#125; 结果: 123 什么 是 机器学习 结语进行分类器的封装以后,可以继续进行之后的文本挖掘内容.以上均为本人拙见,且本人为NLP菜鸟,望大牛予以指正! :)","categories":[{"name":"设计开发","slug":"设计开发","permalink":"http://mikasa.github.io/categories/设计开发/"}],"tags":[{"name":"文本挖掘","slug":"文本挖掘","permalink":"http://mikasa.github.io/tags/文本挖掘/"},{"name":"中文分词","slug":"中文分词","permalink":"http://mikasa.github.io/tags/中文分词/"},{"name":"ICTCLAS","slug":"ICTCLAS","permalink":"http://mikasa.github.io/tags/ICTCLAS/"},{"name":"NLP","slug":"NLP","permalink":"http://mikasa.github.io/tags/NLP/"}],"keywords":[{"name":"设计开发","slug":"设计开发","permalink":"http://mikasa.github.io/categories/设计开发/"}]},{"title":"hdu 5179 BestCoder #31 1002 beautiful number 解题报告","slug":"hdu-5179-BestCoder-31-1002-beautiful-number-瑙ｉ鎶ュ憡","date":"2015-03-07T02:05:51.000Z","updated":"2016-11-24T07:16:14.259Z","comments":true,"path":"2015/03/07/hdu-5179-BestCoder-31-1002-beautiful-number-瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2015/03/07/hdu-5179-BestCoder-31-1002-beautiful-number-瑙ｉ鎶ュ憡/","excerpt":"题目要求找出1e9范围内的满足条件的数，且对于每次查询要给出范围内的数的个数，复杂度条件非常苛刻。 但是该类数本身数量就不多，于是想到离线算出所有数，然后二分答案。 离线求这些数的方法可以DFS或者直接暴力，为了方便我就直接暴力了，半分钟左右出答案。","text":"题目要求找出1e9范围内的满足条件的数，且对于每次查询要给出范围内的数的个数，复杂度条件非常苛刻。 但是该类数本身数量就不多，于是想到离线算出所有数，然后二分答案。 离线求这些数的方法可以DFS或者直接暴力，为了方便我就直接暴力了，半分钟左右出答案。 离线代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int x[9];int len;void work(int n)&#123; int i = 0; while(n&gt;0) &#123; x[i++] = n % 10; n /= 10; &#125; len = i;&#125;int check()&#123; for(int i = 0 ; i &lt; len - 1; i++) if(x[i] &gt; x[i+1]) return 0; for(int i = 0 ; i &lt; len ; i++) if(x[i] == 0) return 0; for(int i = 0 ; i &lt; len - 1; i++) for(int j = i + 1; j &lt; len; j++) if(x[j] % x[i] != 0) return 0; return 1;&#125;int main()&#123; freopen(\"out\",\"w\",stdout); int cnt = 0; for(int i = 1; i &lt;= 999999999; i++) &#123; work(i); if(check()) &#123; cnt++; cout&lt;&lt;i&lt;&lt;\",\"; &#125; &#125; cout&lt;&lt;endl; cout&lt;&lt;cnt&lt;&lt;endl;&#125;`求出这些数大概有1299个，然后对于每次查询，可以直接遍历范围在L～R之间的个数，也可以二分L，二分R，然后序号相减，代码很长，前方高能预警。`#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int f[]=&#123;1,2,3,4,5,6,7,8,9,11,21,22,31,33,41,42,44,51,55,61,62,63,66,71,77,81,82,84,88,91,93,99,111,211,221,222,311,331,333,411,421,422,441,442,444,511,551,555,611,621,622,631,633,661,662,663,666,711,771,777,811,821,822,841,842,844,881,882,884,888,911,931,933,991,993,999,1111,2111,2211,2221,2222,3111,3311,3331,3333,4111,4211,4221,4222,4411,4421,4422,4441,4442,4444,5111,5511,5551,5555,6111,6211,6221,6222,6311,6331,6333,6611,6621,6622,6631,6633,6661,6662,6663,6666,7111,7711,7771,7777,8111,8211,8221,8222,8411,8421,8422,8441,8442,8444,8811,8821,8822,8841,8842,8844,8881,8882,8884,8888,9111,9311,9331,9333,9911,9931,9933,9991,9993,9999,11111,21111,22111,22211,22221,22222,31111,33111,33311,33331,33333,41111,42111,42211,42221,42222,44111,44211,44221,44222,44411,44421,44422,44441,44442,44444,51111,55111,55511,55551,55555,61111,62111,62211,62221,62222,63111,63311,63331,63333,66111,66211,66221,66222,66311,66331,66333,66611,66621,66622,66631,66633,66661,66662,66663,66666,71111,77111,77711,77771,77777,81111,82111,82211,82221,82222,84111,84211,84221,84222,84411,84421,84422,84441,84442,84444,88111,88211,88221,88222,88411,88421,88422,88441,88442,88444,88811,88821,88822,88841,88842,88844,88881,88882,88884,88888,91111,93111,93311,93331,93333,99111,99311,99331,99333,99911,99931,99933,99991,99993,99999,111111,211111,221111,222111,222211,222221,222222,311111,331111,333111,333311,333331,333333,411111,421111,422111,422211,422221,422222,441111,442111,442211,442221,442222,444111,444211,444221,444222,444411,444421,444422,444441,444442,444444,511111,551111,555111,555511,555551,555555,611111,621111,622111,622211,622221,622222,631111,633111,633311,633331,633333,661111,662111,662211,662221,662222,663111,663311,663331,663333,666111,666211,666221,666222,666311,666331,666333,666611,666621,666622,666631,666633,666661,666662,666663,666666,711111,771111,777111,777711,777771,777777,811111,821111,822111,822211,822221,822222,841111,842111,842211,842221,842222,844111,844211,844221,844222,844411,844421,844422,844441,844442,844444,881111,882111,882211,882221,882222,884111,884211,884221,884222,884411,884421,884422,884441,884442,884444,888111,888211,888221,888222,888411,888421,888422,888441,888442,888444,888811,888821,888822,888841,888842,888844,888881,888882,888884,888888,911111,931111,933111,933311,933331,933333,991111,993111,993311,993331,993333,999111,999311,999331,999333,999911,999931,999933,999991,999993,999999,1111111,2111111,2211111,2221111,2222111,2222211,2222221,2222222,3111111,3311111,3331111,3333111,3333311,3333331,3333333,4111111,4211111,4221111,4222111,4222211,4222221,4222222,4411111,4421111,4422111,4422211,4422221,4422222,4441111,4442111,4442211,4442221,4442222,4444111,4444211,4444221,4444222,4444411,4444421,4444422,4444441,4444442,4444444,5111111,5511111,5551111,5555111,5555511,5555551,5555555,6111111,6211111,6221111,6222111,6222211,6222221,6222222,6311111,6331111,6333111,6333311,6333331,6333333,6611111,6621111,6622111,6622211,6622221,6622222,6631111,6633111,6633311,6633331,6633333,6661111,6662111,6662211,6662221,6662222,6663111,6663311,6663331,6663333,6666111,6666211,6666221,6666222,6666311,6666331,6666333,6666611,6666621,6666622,6666631,6666633,6666661,6666662,6666663,6666666,7111111,7711111,7771111,7777111,7777711,7777771,7777777,8111111,8211111,8221111,8222111,8222211,8222221,8222222,8411111,8421111,8422111,8422211,8422221,8422222,8441111,8442111,8442211,8442221,8442222,8444111,8444211,8444221,8444222,8444411,8444421,8444422,8444441,8444442,8444444,8811111,8821111,8822111,8822211,8822221,8822222,8841111,8842111,8842211,8842221,8842222,8844111,8844211,8844221,8844222,8844411,8844421,8844422,8844441,8844442,8844444,8881111,8882111,8882211,8882221,8882222,8884111,8884211,8884221,8884222,8884411,8884421,8884422,8884441,8884442,8884444,8888111,8888211,8888221,8888222,8888411,8888421,8888422,8888441,8888442,8888444,8888811,8888821,8888822,8888841,8888842,8888844,8888881,8888882,8888884,8888888,9111111,9311111,9331111,9333111,9333311,9333331,9333333,9911111,9931111,9933111,9933311,9933331,9933333,9991111,9993111,9993311,9993331,9993333,9999111,9999311,9999331,9999333,9999911,9999931,9999933,9999991,9999993,9999999,11111111,21111111,22111111,22211111,22221111,22222111,22222211,22222221,22222222,31111111,33111111,33311111,33331111,33333111,33333311,33333331,33333333,41111111,42111111,42211111,42221111,42222111,42222211,42222221,42222222,44111111,44211111,44221111,44222111,44222211,44222221,44222222,44411111,44421111,44422111,44422211,44422221,44422222,44441111,44442111,44442211,44442221,44442222,44444111,44444211,44444221,44444222,44444411,44444421,44444422,44444441,44444442,44444444,51111111,55111111,55511111,55551111,55555111,55555511,55555551,55555555,61111111,62111111,62211111,62221111,62222111,62222211,62222221,62222222,63111111,63311111,63331111,63333111,63333311,63333331,63333333,66111111,66211111,66221111,66222111,66222211,66222221,66222222,66311111,66331111,66333111,66333311,66333331,66333333,66611111,66621111,66622111,66622211,66622221,66622222,66631111,66633111,66633311,66633331,66633333,66661111,66662111,66662211,66662221,66662222,66663111,66663311,66663331,66663333,66666111,66666211,66666221,66666222,66666311,66666331,66666333,66666611,66666621,66666622,66666631,66666633,66666661,66666662,66666663,66666666,71111111,77111111,77711111,77771111,77777111,77777711,77777771,77777777,81111111,82111111,82211111,82221111,82222111,82222211,82222221,82222222,84111111,84211111,84221111,84222111,84222211,84222221,84222222,84411111,84421111,84422111,84422211,84422221,84422222,84441111,84442111,84442211,84442221,84442222,84444111,84444211,84444221,84444222,84444411,84444421,84444422,84444441,84444442,84444444,88111111,88211111,88221111,88222111,88222211,88222221,88222222,88411111,88421111,88422111,88422211,88422221,88422222,88441111,88442111,88442211,88442221,88442222,88444111,88444211,88444221,88444222,88444411,88444421,88444422,88444441,88444442,88444444,88811111,88821111,88822111,88822211,88822221,88822222,88841111,88842111,88842211,88842221,88842222,88844111,88844211,88844221,88844222,88844411,88844421,88844422,88844441,88844442,88844444,88881111,88882111,88882211,88882221,88882222,88884111,88884211,88884221,88884222,88884411,88884421,88884422,88884441,88884442,88884444,88888111,88888211,88888221,88888222,88888411,88888421,88888422,88888441,88888442,88888444,88888811,88888821,88888822,88888841,88888842,88888844,88888881,88888882,88888884,88888888,91111111,93111111,93311111,93331111,93333111,93333311,93333331,93333333,99111111,99311111,99331111,99333111,99333311,99333331,99333333,99911111,99931111,99933111,99933311,99933331,99933333,99991111,99993111,99993311,99993331,99993333,99999111,99999311,99999331,99999333,99999911,99999931,99999933,99999991,99999993,99999999,111111111,211111111,221111111,222111111,222211111,222221111,222222111,222222211,222222221,222222222,311111111,331111111,333111111,333311111,333331111,333333111,333333311,333333331,333333333,411111111,421111111,422111111,422211111,422221111,422222111,422222211,422222221,422222222,441111111,442111111,442211111,442221111,442222111,442222211,442222221,442222222,444111111,444211111,444221111,444222111,444222211,444222221,444222222,444411111,444421111,444422111,444422211,444422221,444422222,444441111,444442111,444442211,444442221,444442222,444444111,444444211,444444221,444444222,444444411,444444421,444444422,444444441,444444442,444444444,511111111,551111111,555111111,555511111,555551111,555555111,555555511,555555551,555555555,611111111,621111111,622111111,622211111,622221111,622222111,622222211,622222221,622222222,631111111,633111111,633311111,633331111,633333111,633333311,633333331,633333333,661111111,662111111,662211111,662221111,662222111,662222211,662222221,662222222,663111111,663311111,663331111,663333111,663333311,663333331,663333333,666111111,666211111,666221111,666222111,666222211,666222221,666222222,666311111,666331111,666333111,666333311,666333331,666333333,666611111,666621111,666622111,666622211,666622221,666622222,666631111,666633111,666633311,666633331,666633333,666661111,666662111,666662211,666662221,666662222,666663111,666663311,666663331,666663333,666666111,666666211,666666221,666666222,666666311,666666331,666666333,666666611,666666621,666666622,666666631,666666633,666666661,666666662,666666663,666666666,711111111,771111111,777111111,777711111,777771111,777777111,777777711,777777771,777777777,811111111,821111111,822111111,822211111,822221111,822222111,822222211,822222221,822222222,841111111,842111111,842211111,842221111,842222111,842222211,842222221,842222222,844111111,844211111,844221111,844222111,844222211,844222221,844222222,844411111,844421111,844422111,844422211,844422221,844422222,844441111,844442111,844442211,844442221,844442222,844444111,844444211,844444221,844444222,844444411,844444421,844444422,844444441,844444442,844444444,881111111,882111111,882211111,882221111,882222111,882222211,882222221,882222222,884111111,884211111,884221111,884222111,884222211,884222221,884222222,884411111,884421111,884422111,884422211,884422221,884422222,884441111,884442111,884442211,884442221,884442222,884444111,884444211,884444221,884444222,884444411,884444421,884444422,884444441,884444442,884444444,888111111,888211111,888221111,888222111,888222211,888222221,888222222,888411111,888421111,888422111,888422211,888422221,888422222,888441111,888442111,888442211,888442221,888442222,888444111,888444211,888444221,888444222,888444411,888444421,888444422,888444441,888444442,888444444,888811111,888821111,888822111,888822211,888822221,888822222,888841111,888842111,888842211,888842221,888842222,888844111,888844211,888844221,888844222,888844411,888844421,888844422,888844441,888844442,888844444,888881111,888882111,888882211,888882221,888882222,888884111,888884211,888884221,888884222,888884411,888884421,888884422,888884441,888884442,888884444,888888111,888888211,888888221,888888222,888888411,888888421,888888422,888888441,888888442,888888444,888888811,888888821,888888822,888888841,888888842,888888844,888888881,888888882,888888884,888888888,911111111,931111111,933111111,933311111,933331111,933333111,933333311,933333331,933333333,991111111,993111111,993311111,993331111,993333111,993333311,993333331,993333333,999111111,999311111,999331111,999333111,999333311,999333331,999333333,999911111,999931111,999933111,999933311,999933331,999933333,999991111,999993111,999993311,999993331,999993333,999999111,999999311,999999331,999999333,999999911,999999931,999999933,999999991,999999993,999999999&#125;;int n = 1299;int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; int L,R; cin&gt;&gt;L&gt;&gt;R; int ans = 0; for(int i = 0 ;i &lt; n;i++) &#123; if(f[i]&gt;= L &amp;&amp; f[i]&lt;=R) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"二分答案","slug":"二分答案","permalink":"http://mikasa.github.io/tags/二分答案/"},{"name":"离线查询","slug":"离线查询","permalink":"http://mikasa.github.io/tags/离线查询/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"Hdu 5178 BestCoder #31 1001 Pairs 解题报告","slug":"Hdu-5178-BestCoder-31-1001-Pairs-瑙ｉ鎶ュ憡","date":"2015-03-06T04:36:36.000Z","updated":"2016-11-24T07:16:14.025Z","comments":true,"path":"2015/03/06/Hdu-5178-BestCoder-31-1001-Pairs-瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2015/03/06/Hdu-5178-BestCoder-31-1001-Pairs-瑙ｉ鎶ュ憡/","excerpt":"题意简单，找到线段上距离小于k的点对的个数。 解法为，先排序所有点，然后遍历每个点x[a]，二分刚好小于b=x[a]+k的所在点下标，表示a和a+1～b之间的点都为符合点。然后累加b-a即可。 用lower_bound会WA，要用upper_bound或者自己手写二分，问题出在当x[b]=x[a]+k时的区别。","text":"题意简单，找到线段上距离小于k的点对的个数。 解法为，先排序所有点，然后遍历每个点x[a]，二分刚好小于b=x[a]+k的所在点下标，表示a和a+1～b之间的点都为符合点。然后累加b-a即可。 用lower_bound会WA，要用upper_bound或者自己手写二分，问题出在当x[b]=x[a]+k时的区别。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;#define LL long long#define MAXN 100005int x[MAXN];int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; int n,k; scanf(\"%d%d\",&amp;n,&amp;k); for(int i = 0 ; i &lt; n ; i++) &#123; scanf(\"%d\",&amp;x[i]); &#125; sort(x,x+n); LL ans = 0; for(int i = 0; i &lt; n; i++) &#123; int b = upper_bound(x + i + 1, x + n, x[i] + k) - x - i - 1; // cout&lt;&lt;b&lt;&lt;endl; ans += b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://mikasa.github.io/tags/二分/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"BestCoder #29 1002 hdu 5171 GTY's birthday gift 题解","slug":"BestCoder-29-1002-hdu-5171-GTY-s-birthday-gift-棰樿В","date":"2015-02-07T13:56:20.000Z","updated":"2016-11-24T07:16:13.900Z","comments":true,"path":"2015/02/07/BestCoder-29-1002-hdu-5171-GTY-s-birthday-gift-棰樿В/","link":"","permalink":"http://mikasa.github.io/2015/02/07/BestCoder-29-1002-hdu-5171-GTY-s-birthday-gift-棰樿В/","excerpt":"假期放松了太多，状态太差，水题都WA了好几发。。 先是第一题，思路很简单，取个对数判断大小就行了，然后脑抽了居然直接用“==”进行判断，事实上应该要用精度判断，然后卡到第二题做出来才想到。。ORZ 然后是第二题，读题后很容易可以发现最后的答案是取最大的2个数a,b，进行相加，然后得到第三个数a+b，再相加得到a+2b，反复下去类似斐波那契数列。然后可以得出a的系数是从斐波那契的某一项开始的前n项和-1，b同理是前某项和-2，然后用矩阵快速幂o(log(n))轻松搞定斐波那契，再加上数列所有数的和即可。 官方题解是直接从线性方程推出转移矩阵，然后根据三阶矩阵快速幂求得解，同样可用。","text":"假期放松了太多，状态太差，水题都WA了好几发。。 先是第一题，思路很简单，取个对数判断大小就行了，然后脑抽了居然直接用“==”进行判断，事实上应该要用精度判断，然后卡到第二题做出来才想到。。ORZ 然后是第二题，读题后很容易可以发现最后的答案是取最大的2个数a,b，进行相加，然后得到第三个数a+b，再相加得到a+2b，反复下去类似斐波那契数列。然后可以得出a的系数是从斐波那契的某一项开始的前n项和-1，b同理是前某项和-2，然后用矩阵快速幂o(log(n))轻松搞定斐波那契，再加上数列所有数的和即可。 官方题解是直接从线性方程推出转移矩阵，然后根据三阶矩阵快速幂求得解，同样可用。 这里值得一提的是，我竟然直接无视题目中的mod 10000007，然后想当然地感觉这个数会按往常一样取int范围内最大的质数1000000007，然后按着事先打好的模板，结果failed final test了。。这也警告之后不能按照打好的模板来。。还是得自己纯手打好。。 HACK时看到好多人直接for循环跑。。交了两发，都Invalid Input的了，听群里人才知道。。数据最后要换行。。ORZ 本来这场2题保证涨分，紫名近在眼前。。可惜啊，还是要努力啊！ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int N = 2;const long long MOD = 10000007;LL a[100005];struct Mat&#123; LL m[N][N];&#125;;Mat operator * (Mat a,Mat b)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i = 0 ; i &lt; N; i++) for(int j = 0 ; j &lt; N; j++) for(int k = 0 ; k &lt; N; k++) &#123; c.m[i][j] = (c.m[i][j]%MOD + (a.m[i][k]%MOD) * (b.m[k][j]% MOD) % MOD) % MOD; &#125; return c;&#125;Mat operator ^ (Mat a,LL k)&#123; Mat c; memset(c.m,0,sizeof(c.m)); for(int i = 0; i &lt; N; i++) c.m[i][i] = 1; while(k)&#123; if(k&amp;1) c = c * a; a = a * a; k &gt;&gt;= 1; &#125; return c;&#125;LL quick_pow(LL a,LL n)&#123; LL tmp = 1; while(n)&#123; if(n&amp;1) tmp = tmp * a % MOD; n &gt;&gt;= 1; a = a * a % MOD; &#125; return tmp;&#125;int main()&#123; freopen(\"in.txt\",\"r\",stdin); LL n,k; while(~scanf(\"%I64d%I64d\",&amp;n,&amp;k)) &#123; LL mx = 0; LL mxx = 0; LL sum = 0; for(int i = 0 ; i &lt;n;i++) &#123; scanf(\"%I64d\",&amp;a[i]); sum = (sum + a[i])%MOD; if(a[i]&gt;mx) &#123; mxx = mx; mx = a[i]; &#125; else if(a[i]&gt;mxx) mxx = a[i]; &#125; sort(a,a+n); mx = a[n-1]% MOD; mxx = a[n-2]% MOD; //cout&lt;&lt;mx&lt;&lt;\" \"&lt;&lt;mxx&lt;&lt;endl; //cout&lt;&lt;sum&lt;&lt;endl; Mat base = &#123;1,1,1,0&#125;; Mat mm = base ^ (k+2); LL c = mm.m[0][1]-1 % MOD; LL d = mm.m[0][0]-2 % MOD; // LL ans = (mx * d% MOD + mxx*c% MOD + sum% MOD)%MOD; //cout&lt;&lt;c&lt;&lt;\" \"&lt;&lt;d&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"矩阵快速幂","slug":"矩阵快速幂","permalink":"http://mikasa.github.io/tags/矩阵快速幂/"},{"name":"斐波那契","slug":"斐波那契","permalink":"http://mikasa.github.io/tags/斐波那契/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"BestCoder #28 1002 Fibonacci hdu 5167 解题报告","slug":"BestCoder-28-1002-Fibonacci-hdu-5167-瑙ｉ鎶ュ憡","date":"2015-02-03T07:20:35.000Z","updated":"2016-11-24T07:16:13.884Z","comments":true,"path":"2015/02/03/BestCoder-28-1002-Fibonacci-hdu-5167-瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2015/02/03/BestCoder-28-1002-Fibonacci-hdu-5167-瑙ｉ鎶ュ憡/","excerpt":"题目很简单，就是给出一个n，判断n能否由斐波那契数相乘得到，n范围为1e9。 先判断了一下，该范围大概有40来个数，先预处理保存这些数即可。 一开始的思路是对于每个数直接进行dfs，判断能否能够达到该n，但是写的太烂，加上case T的范围是1e5，结果TLE了。之后看了看别人代码的思路，找到了一种比较好的方法。","text":"题目很简单，就是给出一个n，判断n能否由斐波那契数相乘得到，n范围为1e9。 先判断了一下，该范围大概有40来个数，先预处理保存这些数即可。 一开始的思路是对于每个数直接进行dfs，判断能否能够达到该n，但是写的太烂，加上case T的范围是1e5，结果TLE了。之后看了看别人代码的思路，找到了一种比较好的方法。 先预处理所有能达到的乘积，然后对于每次查询二分答案即可。测试了下，处理完所有范围的数，大概在80ms左右，看来还是不错的。 dfs的主体内容就是： 12345for i:= t to cnt val *= f[i];dfs(i,val); 其中t为当前搜索的index，val为当前乘积值，再加上一些限制条件就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;#define INF 1000000000#define LL long longLL f[100];int vis[100];int cnt;int flag;LL now = 1;LL n;vector&lt;LL&gt; v;vector&lt;LL&gt;::iterator it;void dfs(int t,LL val) &#123; //cout&lt;&lt;t&lt;&lt;\" \"&lt;&lt;val&lt;&lt;endl; v.push_back(val); if(t &gt;= cnt) return; for(int i = t; i &lt; cnt; i++) &#123; LL tmp = val * f[i]; if(tmp &gt; INF) break; dfs(i,tmp); &#125;&#125;void init() &#123; f[0] = 0; f[1] = 1; cnt = 2; for(int i = 2;f[i] &lt; 100;i++) &#123; f[i] = f[i-1] + f[i-2]; if(f[i] &gt; INF) break; cnt++; &#125; //cnt = 5; v.push_back(0); dfs(3,1); sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());&#125;int main() &#123; #ifndef ONLINE_JUDGE freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); #endif init(); int T; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; flag = 0; memset(vis,0,sizeof(vis)); it = lower_bound(v.begin(),v.end(),n); if( it!= v.end() &amp;&amp; *it== n) flag = 1; if(!flag) puts(\"No\"); else puts(\"Yes\"); &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://mikasa.github.io/tags/dfs/"},{"name":"BestCoder","slug":"BestCoder","permalink":"http://mikasa.github.io/tags/BestCoder/"},{"name":"hdu","slug":"hdu","permalink":"http://mikasa.github.io/tags/hdu/"},{"name":"fibonacci","slug":"fibonacci","permalink":"http://mikasa.github.io/tags/fibonacci/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"BestCoder #26 1002 Card  期望 解题报告","slug":"BestCoder-26-1002-Card-鏈熸湜-瑙ｉ鎶ュ憡","date":"2015-01-27T12:12:10.000Z","updated":"2016-11-24T07:16:13.869Z","comments":true,"path":"2015/01/27/BestCoder-26-1002-Card-鏈熸湜-瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2015/01/27/BestCoder-26-1002-Card-鏈熸湜-瑙ｉ鎶ュ憡/","excerpt":"题目的意思是，从x张牌里抽1张牌，然后放回重复b次，Sj为每次抽出牌的积分之和，问Sj的期望。 一开始看这个题目的时候考虑用组合做，因为b最大为5，所以考虑Sj由5个数-1个数组成的情况，然后算概率，但是题目的a和T的范围太大，O(Tlog(a))都会T估计，这明摆着是要O(T)的节奏啊。。也就是说，给定一个x，一个b，就有公式可以推出答案。 然后从另一个方向考虑，如果从组合考虑，即使给定几个数被抽到，还得考虑顺序情况，相当复杂，于是可以考虑对于每个数，其实只有2种状态（选中OR未选中），根据这两种状态去求期望会方便很多。 每次抽牌，选中某一张牌的概率为1/x； 抽b次牌结束后，某张牌被抽中概率为p = 1-(1-1/x)^b，（转化为相反的事件再转化回来）。 因此抽中某一张牌对期望的贡献为 i p ，因此总期望为 ∑(i=1~x) i p ，即EX = (x + 1)x (1-(1-1/x)^b)。","text":"题目的意思是，从x张牌里抽1张牌，然后放回重复b次，Sj为每次抽出牌的积分之和，问Sj的期望。 一开始看这个题目的时候考虑用组合做，因为b最大为5，所以考虑Sj由5个数-1个数组成的情况，然后算概率，但是题目的a和T的范围太大，O(Tlog(a))都会T估计，这明摆着是要O(T)的节奏啊。。也就是说，给定一个x，一个b，就有公式可以推出答案。 然后从另一个方向考虑，如果从组合考虑，即使给定几个数被抽到，还得考虑顺序情况，相当复杂，于是可以考虑对于每个数，其实只有2种状态（选中OR未选中），根据这两种状态去求期望会方便很多。 每次抽牌，选中某一张牌的概率为1/x； 抽b次牌结束后，某张牌被抽中概率为p = 1-(1-1/x)^b，（转化为相反的事件再转化回来）。 因此抽中某一张牌对期望的贡献为 i p ，因此总期望为 ∑(i=1~x) i p ，即EX = (x + 1)x (1-(1-1/x)^b)。 代码： 12345678910111213141516171819#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int cnt = 0; int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; cnt++; double x; int b; scanf(\"%lf%d\",&amp;x,&amp;b); double p = 1.0; for(int i = 0; i &lt; b; i++) p *= (1 - 1/x); double ans = (1 - p) * (x + 1) * x / 2; printf(\"Case #%d: %.3f\\n\",cnt,ans); &#125; &#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"期望","slug":"期望","permalink":"http://mikasa.github.io/tags/期望/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"Codeforces #285 C Misha and Forest 队列维护 解题报告","slug":"Codeforces-285-C-Misha-and-Forest-闃熷垪缁存姢-瑙ｉ鎶ュ憡","date":"2015-01-14T15:04:10.000Z","updated":"2016-11-24T07:16:13.962Z","comments":true,"path":"2015/01/14/Codeforces-285-C-Misha-and-Forest-闃熷垪缁存姢-瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2015/01/14/Codeforces-285-C-Misha-and-Forest-闃熷垪缁存姢-瑙ｉ鎶ュ憡/","excerpt":"题目大意为一个森林，对于每个节点记录它的度数degree和与它连接的点的异或和Sv。现在给出每个点的degree和Sv，求这个图有多少条边，并写出每条边的顶点。 分析： 首先从异或和出发，加入x^y^z = a，那么左右都异或x的话，(x^x)^y^z = a^x，即y^z = a^x，同理z = a^x^y。 其次由于是森林，肯定有叶子节点，找出这些叶子节点，他们的degree均为1，且Sv为父节点的编号，每遍历一个叶子节点，将其父节点度数-1，Sv异或叶子节点编号，直到找到最后一个节点即可。 最后，需要用队列维护，不然会T。","text":"题目大意为一个森林，对于每个节点记录它的度数degree和与它连接的点的异或和Sv。现在给出每个点的degree和Sv，求这个图有多少条边，并写出每条边的顶点。 分析： 首先从异或和出发，加入x^y^z = a，那么左右都异或x的话，(x^x)^y^z = a^x，即y^z = a^x，同理z = a^x^y。 其次由于是森林，肯定有叶子节点，找出这些叶子节点，他们的degree均为1，且Sv为父节点的编号，每遍历一个叶子节点，将其父节点度数-1，Sv异或叶子节点编号，直到找到最后一个节点即可。 最后，需要用队列维护，不然会T。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; struct node&#123; int degree,s,i; int vis; void output()&#123; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;degree&lt;&lt;\" \"&lt;&lt;s&lt;&lt;endl; &#125; &#125;v[70000]; typedef pair&lt;int, int&gt; PII; vector&lt;PII&gt; edge; vector&lt;PII&gt;::iterator it; queue &lt;int&gt; q; int main() &#123; freopen(\"in.txt\",\"r\",stdin); int n; scanf(\"%d\",&amp;n); int cnt = 0; for(int i = 0 ; i &lt; n;i++) &#123; scanf(\"%d%d\",&amp;v[i].degree,&amp;v[i].s); if(v[i].degree == 1) q.push(i); &#125; while(!q.empty()) &#123; int i = q.front(); q.pop(); if(v[i].degree == 1) &#123; int fa = v[i].s; v[fa].s ^= i; v[fa].degree --; edge.push_back(make_pair(i,fa)); if(v[fa].degree == 1) q.push(fa); &#125; &#125; cout&lt;&lt;edge.size()&lt;&lt;endl; for(it = edge.begin();it!=edge.end();it++) &#123; PII pb = *it; cout&lt;&lt;pb.first&lt;&lt;\" \"&lt;&lt;pb.second&lt;&lt;endl; &#125; &#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"队列","slug":"队列","permalink":"http://mikasa.github.io/tags/队列/"},{"name":"森林","slug":"森林","permalink":"http://mikasa.github.io/tags/森林/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"CodeForces #285 B题Misha and Changing Handles解题报告","slug":"CodeForces-285-B棰楳isha-and-Changing-Handles瑙ｉ鎶ュ憡","date":"2015-01-14T14:48:12.000Z","updated":"2016-11-24T07:16:13.931Z","comments":true,"path":"2015/01/14/CodeForces-285-B棰楳isha-and-Changing-Handles瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2015/01/14/CodeForces-285-B棰楳isha-and-Changing-Handles瑙ｉ鎶ュ憡/","excerpt":"本题的意思是，给定多个改名的查询，每个查询包括一个新名字和旧名字，一个人可以多次更改，最终得到一个新名字，求这些查询中一共有多少个人，并且输出他最初的名字和最后的名字。(1&lt;=q&lt;=100）","text":"本题的意思是，给定多个改名的查询，每个查询包括一个新名字和旧名字，一个人可以多次更改，最终得到一个新名字，求这些查询中一共有多少个人，并且输出他最初的名字和最后的名字。(1&lt;=q&lt;=100） 1234567891011121314151617181920212223input5Misha ILoveCodeforcesVasya PetrovPetrov VasyaPetrov123ILoveCodeforces MikeMirzayanovPetya Ivanovoutput3Petya IvanovMisha MikeMirzayanovVasya VasyaPetrov123 考虑到q比较小，所以可以瞎搞。。直接对于每个节点设置sid和pid分别连接下一个名字和上一个名字，对于每一个查询，维护它的前驱和后继，最后便利一遍找到没有sid和没有pid的就是最初和最末的名字，最后根据循环找出每个初始名的结束名即可。 比的时候居然没注意到要用2*q存储，结果RE了，这点要注意。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; struct node&#123; string v; int pid; int sid; void output()&#123; cout&lt;&lt;v&lt;&lt;\" \"&lt;&lt;pid&lt;&lt;\" \"&lt;&lt;sid&lt;&lt;endl; &#125; &#125;f[1001]; int main() &#123; freopen(\"in.txt\",\"r\",stdin); int n; while(cin&gt;&gt;n) &#123; for(int i = 0; i &lt; n ; i++) &#123; f[i].pid = -1; f[i].sid = -1; &#125; int cnt = 0; int tmp; for(int i = 0 ;i &lt; n; i++) &#123; string a,b; cin&gt;&gt;a&gt;&gt;b; int j; for(j = 0;j &lt; cnt;j++) if(a==f[j].v) break; if(j==cnt) &#123; f[cnt].v = a; f[cnt].pid = -1; f[cnt].sid = cnt + 1; cnt++; f[cnt].v = b; f[cnt].pid = cnt-1; f[cnt].sid = -1; cnt++; &#125; else &#123; f[cnt].v = b; f[cnt].pid = j; f[j].sid = cnt; f[cnt].sid = -1; cnt++; &#125; &#125; // for(int i = 0 ; i &lt; cnt ;i++) // &#123; // f[i].output(); // &#125; int ans = 0; for(int i = 0 ; i &lt; cnt;i++) &#123; if(f[i].pid == -1) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i = 0 ; i &lt; cnt;i++) &#123; if(f[i].pid == -1) &#123; int si = f[i].sid; int pi ; while(si!=-1) &#123; pi = si; si = f[si].sid; &#125; cout&lt;&lt;f[i].v&lt;&lt;\" \"&lt;&lt;f[pi].v&lt;&lt;endl; &#125; &#125; &#125; &#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://mikasa.github.io/tags/CodeForces/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"hdu 5124 BestCoder #20 1002 lines 解题报告","slug":"hdu-5124-BestCoder-20-1002-lines-瑙ｉ鎶ュ憡","date":"2014-11-29T22:11:56.000Z","updated":"2016-11-24T07:16:14.243Z","comments":true,"path":"2014/11/30/hdu-5124-BestCoder-20-1002-lines-瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2014/11/30/hdu-5124-BestCoder-20-1002-lines-瑙ｉ鎶ュ憡/","excerpt":"这道题和以前做过的一道很像，然后哗啦哗啦就敲了提交了，然后pretest pass了 ，交了以后发现有问题，我的方法只是对一维数组进行标记然后扫描一遍，但是对于1e9的数据不仅爆数组又会T。想了一会儿怎么改进，最后还是卡这了。 赛后想了想，做一个简单的映射就行了，在原来的数组上相当于再加一层数组，对当前数组的index也就是上层数组的value进行标记扫描，就好过了。。。 将线段的x和y都放在一个数组v里，然后对2*n大小的v数组排序，然后对于每一个x，二分查找v数组的lower_bound，然后标记++，对于每一个y,二分查找v数组的lower_bound，然后标记–，最后扫描一遍OK了。。","text":"这道题和以前做过的一道很像，然后哗啦哗啦就敲了提交了，然后pretest pass了 ，交了以后发现有问题，我的方法只是对一维数组进行标记然后扫描一遍，但是对于1e9的数据不仅爆数组又会T。想了一会儿怎么改进，最后还是卡这了。 赛后想了想，做一个简单的映射就行了，在原来的数组上相当于再加一层数组，对当前数组的index也就是上层数组的value进行标记扫描，就好过了。。。 将线段的x和y都放在一个数组v里，然后对2*n大小的v数组排序，然后对于每一个x，二分查找v数组的lower_bound，然后标记++，对于每一个y,二分查找v数组的lower_bound，然后标记–，最后扫描一遍OK了。。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int a[maxn],b[maxn];int f[maxn * 2];int v[maxn * 2];int main()&#123; freopen(\"in.txt\",\"r\",stdin); int T; cin&gt;&gt;T; while(T--) &#123; int n; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(f,0,sizeof(f)); memset(v,0,sizeof(v)); scanf(\"%d\",&amp;n); for(int i = 0 ; i &lt;n ; i++) &#123; scanf(\"%d%d\",&amp;a[i],&amp;b[i]); f[i] = a[i]; f[i+n] = b[i]; &#125; sort(f,f+n*2); for(int i = 0; i &lt; n ; i++) &#123; int aa = lower_bound(f, f+2*n,a[i])-f; int bb = lower_bound(f, f+2*n, b[i])-f; v[aa]++; v[bb+1]--; &#125; int tmp = 0,ans= 0; for(int i = 0 ; i &lt; n*2;i++) &#123; tmp += v[i]; ans = max(ans,tmp); &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"标记法","slug":"标记法","permalink":"http://mikasa.github.io/tags/标记法/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"hdu 4135 Co-prime 容斥原理","slug":"hdu-4135-Co-prime-瀹规枼鍘熺悊","date":"2014-11-27T17:27:33.000Z","updated":"2016-11-24T07:16:14.228Z","comments":true,"path":"2014/11/28/hdu-4135-Co-prime-瀹规枼鍘熺悊/","link":"","permalink":"http://mikasa.github.io/2014/11/28/hdu-4135-Co-prime-瀹规枼鍘熺悊/","excerpt":"最近在看容斥原理的题目，这道题目是很典型的。 题目要求求[L,R]区间内与k互斥的数有多少个。 可以用容斥原理求[1,R]中与k互斥的个数，再减去[1,L-1]中与k互斥的个数。 容斥原求[1,n]中与k互斥的数的思路是：对于k，先分解质因数，放在prime[i]里，然后对于每个因数的各个组合，求[1,n]中能被其整除的个数，即n/prime[i]，然后不能直接相加。 比如说30的因数是2,3,5。求[1,20]中与30互斥的数，先要求20/2,20/3,20/5，然后求20/6,20/10,20/15，最后求20/30。 由2个因数组成的除数，要减，一个因数组成的，则加。 再讲怎么取到这每一个组合。用位运算表示最方便了。如i=3用011表示，就是要取prime[0]，prime[1]。 因此只要循环i := 1 -&gt; 2^cnt (因数个数) ，j := 0 -&gt; cnt -1 ，若 (1&lt;&lt;(j+1)) &amp; 1 不为0，则要取到该数。如i = 3,要取到prime[0]和prime[1]，1&lt;&lt;1 = “ 001”， 1&lt;&lt;2 = “010”，则符合。 最后说一下题目里的坑，因为a,b，n都是long long 范围，所以循环变量i需要也为long long ，且函数返回也为long long ，prime[]数组也是long long ，总之精度不能有错。 然后是long long 的问题，hdoj long long 用%lld居然会WA，然后卡了我好几次，最后改为%I64d过了。。","text":"最近在看容斥原理的题目，这道题目是很典型的。 题目要求求[L,R]区间内与k互斥的数有多少个。 可以用容斥原理求[1,R]中与k互斥的个数，再减去[1,L-1]中与k互斥的个数。 容斥原求[1,n]中与k互斥的数的思路是：对于k，先分解质因数，放在prime[i]里，然后对于每个因数的各个组合，求[1,n]中能被其整除的个数，即n/prime[i]，然后不能直接相加。 比如说30的因数是2,3,5。求[1,20]中与30互斥的数，先要求20/2,20/3,20/5，然后求20/6,20/10,20/15，最后求20/30。 由2个因数组成的除数，要减，一个因数组成的，则加。 再讲怎么取到这每一个组合。用位运算表示最方便了。如i=3用011表示，就是要取prime[0]，prime[1]。 因此只要循环i := 1 -&gt; 2^cnt (因数个数) ，j := 0 -&gt; cnt -1 ，若 (1&lt;&lt;(j+1)) &amp; 1 不为0，则要取到该数。如i = 3,要取到prime[0]和prime[1]，1&lt;&lt;1 = “ 001”， 1&lt;&lt;2 = “010”，则符合。 最后说一下题目里的坑，因为a,b，n都是long long 范围，所以循环变量i需要也为long long ，且函数返回也为long long ，prime[]数组也是long long ，总之精度不能有错。 然后是long long 的问题，hdoj long long 用%lld居然会WA，然后卡了我好几次，最后改为%I64d过了。。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)//#define WE freopen(\"out.txt\",\"w\",stdout) const int maxn = 70;LL prime[maxn];LL a,b,n;int cnt;int t = 0;LL solve(LL num)&#123; LL ans = 0; for(LL i = 1; i &lt; (LL)1&lt;&lt;cnt; i++)&#123; LL flag = 0, tmp = 1; for(LL j = 0; j &lt; cnt; j++)&#123; if(i &amp; (1&lt;&lt;j))&#123; tmp *= prime[j]; flag ++; &#125; &#125; if(flag &amp; 1)&#123; ans += num/tmp; &#125; else&#123; ans -= num/tmp; &#125; &#125; return num - ans;&#125;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; t++; scanf(\"%I64d%I64d%I64d\",&amp;a,&amp;b,&amp;n); cnt = 0; for(LL i = 2; i*i &lt;= n;i++)&#123; if(n&amp;&amp;n%i == 0)&#123; prime[cnt++] = i; while(n&amp;&amp;n%i == 0)&#123; n /= i; &#125; &#125; &#125; if(n &gt; 1)&#123; prime[cnt++] = n; &#125; printf(\"Case #%d: %I64d\\n\",t,solve(b)-solve(a-1)); &#125; return 0; &#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"容斥原理","slug":"容斥原理","permalink":"http://mikasa.github.io/tags/容斥原理/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"Codeforces #279 A Team Olympiad 瞎搞","slug":"Codeforces-279-A-Team-Olympiad-鐬庢悶","date":"2014-11-24T16:30:27.000Z","updated":"2016-11-24T07:16:13.947Z","comments":true,"path":"2014/11/25/Codeforces-279-A-Team-Olympiad-鐬庢悶/","link":"","permalink":"http://mikasa.github.io/2014/11/25/Codeforces-279-A-Team-Olympiad-鐬庢悶/","excerpt":"难得一场CF在下午5点打，果断参加，涨了100多分～ A题比较水，说的是n个学生，分别擅长体育，数学， 编程，要求把他们分成几组，每组里必须有会编程，会体育，会数学的各一人，求最多分多少组。 其实就是将三类学生分类，找到人数最少的一类，瞎搞搞就过了。","text":"难得一场CF在下午5点打，果断参加，涨了100多分～ A题比较水，说的是n个学生，分别擅长体育，数学， 编程，要求把他们分成几组，每组里必须有会编程，会体育，会数学的各一人，求最多分多少组。 其实就是将三类学生分类，找到人数最少的一类，瞎搞搞就过了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=5001;int a[maxn];int b[maxn];int c[maxn];int n;int main()&#123; cin&gt;&gt;n; int ax = 0, bx = 0, cx = 0; for(int i = 0;i&lt;n;i++) &#123; int tmp; cin&gt;&gt;tmp; if(tmp == 1) &#123; a[ax++] = i; &#125; if(tmp == 2)&#123; b[bx++] = i; &#125; if(tmp == 3)&#123; c[cx++] = i; &#125; &#125; if(ax==0||bx==0||cx==0)&#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; int ans = 0; ans = min(ax,bx); ans = min(ans,cx); cout&lt;&lt;ans&lt;&lt;endl; for(int i = 0; i &lt; ans; i++) &#123; cout&lt;&lt;a[i]+1&lt;&lt;\" \"&lt;&lt;b[i]+1&lt;&lt;\" \"&lt;&lt;c[i]+1; cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://mikasa.github.io/tags/CodeForces/"},{"name":"水题","slug":"水题","permalink":"http://mikasa.github.io/tags/水题/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"HDU 5104 BestCoder #18 1001 Primes Problem 水题","slug":"HDU-5104-BestCoder-18-1001-Primes-Problem-姘撮","date":"2014-11-19T13:39:37.000Z","updated":"2016-11-24T07:16:13.994Z","comments":true,"path":"2014/11/19/HDU-5104-BestCoder-18-1001-Primes-Problem-姘撮/","link":"","permalink":"http://mikasa.github.io/2014/11/19/HDU-5104-BestCoder-18-1001-Primes-Problem-姘撮/","excerpt":"题意为对于每个n，求有多少种组合(a,b,c),a&lt;=b&lt;=c，a、b、c都是素数 事先打个1-10000的素数表，然后穷举a和b判断c是否为素数即可","text":"题意为对于每个n，求有多少种组合(a,b,c),a&lt;=b&lt;=c，a、b、c都是素数 事先打个1-10000的素数表，然后穷举a和b判断c是否为素数即可 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)//#define WE freopen(\"out.txt\",\"w\",stdout) const int maxn = 10000;int notprime[maxn+1];int prime[maxn+1];int cnt = 0; void init()&#123; memset(notprime,0,sizeof(prime)); notprime[0] = notprime[1] = true; for(int i = 2; i &lt; maxn; i++) &#123; if(!notprime[i]) &#123; if(i &gt; maxn / i) continue; for(int j = i * i; j &lt; maxn; j+=i) notprime[j] = 1; &#125; &#125; &#125; void getPrime()&#123; for(int i = 2; i &lt; maxn; i++) &#123; if(!notprime[i]) &#123; prime[cnt++] = i; &#125; &#125; &#125;int main()&#123; init(); getPrime(); int n; while(cin&gt;&gt;n) &#123; int ans = 0; for(int i = 0;prime[i] &lt;= n / 3;i++) for(int j = i ;n-prime[i]-prime[j]&gt;=prime[j];j++) &#123; int tmp = n - prime[i] - prime[j]; if(!notprime[tmp]) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"水题","slug":"水题","permalink":"http://mikasa.github.io/tags/水题/"},{"name":"素数","slug":"素数","permalink":"http://mikasa.github.io/tags/素数/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"Hadoop java api ，HDFS文件操作，便于Web开发的集合","slug":"Hadoop-java-api-锛孒DFS鏂囦欢鎿嶄綔锛屼究浜嶹eb寮€鍙戠殑闆嗗悎","date":"2014-11-05T20:58:45.000Z","updated":"2016-11-24T07:16:14.009Z","comments":true,"path":"2014/11/06/Hadoop-java-api-锛孒DFS鏂囦欢鎿嶄綔锛屼究浜嶹eb寮€鍙戠殑闆嗗悎/","link":"","permalink":"http://mikasa.github.io/2014/11/06/Hadoop-java-api-锛孒DFS鏂囦欢鎿嶄綔锛屼究浜嶹eb寮€鍙戠殑闆嗗悎/","excerpt":"最近在搞一个云计算比赛，要开发HDFS存储云，根据一个博客给的API写了一个完整的JAVA文件集成所有的HDFS文件操作，后期用JSP开发时只要导入这个包就OK了。","text":"最近在搞一个云计算比赛，要开发HDFS存储云，根据一个博客给的API写了一个完整的JAVA文件集成所有的HDFS文件操作，后期用JSP开发时只要导入这个包就OK了。 感谢原作者：http://www.cnblogs.com/xuqiang/archive/2011/06/03/2042526.html 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.net.URI;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.BlockLocation;import org.apache.hadoop.fs.FSDataInputStream;import org.apache.hadoop.fs.FSDataOutputStream;import org.apache.hadoop.fs.FileStatus;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;public class HadoopFileUtil &#123;/** * HDFS文件访问API * @author Jet-Muffin */ public static String hdfsUrl = \"hdfs://localhost:9000\"; /** * create HDFS folder 创建一个文件夹 * @param dirPath * @return */ public static void createDir(String dirPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(dirPath); hdfs.mkdirs(path); hdfs.close(); &#125; /** * delete HDFS folder 删除一个文件夹 * @param dirPath * @return */ public static void deleteDir(String dirPath) throws Exception&#123; Configuration conf = new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); hdfs.delete(new Path(dirPath)); hdfs.close(); &#125; /** * create a file 创建一个文件 * @param filePath * @return */ public static void createFile(String filePath,String content) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(filePath); FSDataOutputStream out = hdfs.create(path); out.write(content.getBytes()); out.close(); hdfs.close(); &#125; /** * rename a file 重命名一个文件 * @param oldPath * @param newPath * @return */ public static void renameFile(String oldPath,String newPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(oldPath); Path nPath = new Path(newPath); hdfs.close(); System.out.println(hdfs.rename(path, nPath)); &#125; /** * delete a file 删除一个文件 * @param hadoopFile * @return isDeleted */ public static boolean deleteFile(String hadoopFile) throws Exception&#123; Configuration conf=new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(hadoopFile); boolean isDeleted = hdfs.delete(path); hdfs.close(); return isDeleted; &#125; /** * upload a local file 上传文件 * @param localPath * @param hadoopPath * @return */ public static void uploadLocalFile(String localPath,String hadoopPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path src = new Path(localPath); Path dst = new Path(hadoopPath); hdfs.copyFromLocalFile(src, dst); hdfs.close(); &#125; /** * 读取文件于字节缓冲数组 * @param hadoopFile * @return buffer */ public static byte[] readFile(String hadoopFile) throws Exception &#123; Configuration conf = new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path path = new Path(hadoopFile); if ( hdfs.exists(path) ) &#123; FSDataInputStream in = hdfs.open(path); FileStatus stat = hdfs.getFileStatus(path); byte[] buffer = new byte[Integer.parseInt(String.valueOf(stat.getLen()))]; in.readFully(0, buffer); in.close(); hdfs.close(); return buffer; &#125; else &#123; throw new Exception(\"the file is not found .\"); &#125; &#125; /** * list files under folder 列出文件夹中所有文件 * @param hadoopPath * @return fileString */ public static String listFiles(String hadoopPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path dst = new Path(\"/test\"); FileStatus[] files = hdfs.listStatus(dst); String fileString = \"\"; for(FileStatus file: files)&#123; System.out.println(file.getPath().toString()); fileString += file.getPath().toString() + \" \"; &#125; hdfs.close(); return fileString; &#125; /** * list block info of file 查找文件所在的数据块 * @param hadoopPath * @return blockString */ public static String getBlockInfo(String hadoopPath) throws Exception&#123; Configuration conf= new Configuration(); FileSystem hdfs = FileSystem.get(URI.create(hdfsUrl),conf); Path dst = new Path(hadoopPath); FileStatus fileStatus = hdfs.getFileStatus(dst); BlockLocation[] blkloc=hdfs.getFileBlockLocations(fileStatus,0,fileStatus.getLen()); //查找文件所在数据块 String blockString = \"\"; for(BlockLocation loc: blkloc)&#123; for(int i=0;i &lt; loc.getHosts().length;i++) System.out.println(loc.getHosts()[i]); // blockString += loc.getHosts()[i] + \" \"; &#125; hdfs.close(); return blockString; &#125; public static void main(String[] args) throws Exception &#123; //createDir(\"/test2\"); //deleteDir(\"/test2\"); //createFile(\"/test/helloworld.txt\"); //renameFile(\"/test/a.txt\",\"/test/b.txt\"); //uploadLocalFile(\"/home/had/in\",\"/test\"); //listFiles(\"/test\"); //getBlockInfo(\"/test/b.txt\"); //deleteFile(\"/test/hellwo.txt\"); /* byte[] buffer = readFile(\"/test/in\"); String out = new String(buffer); System.out.println(out); */ &#125; &#125;","categories":[{"name":"分布式计算","slug":"分布式计算","permalink":"http://mikasa.github.io/categories/分布式计算/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://mikasa.github.io/tags/Hadoop/"},{"name":"HDFS","slug":"HDFS","permalink":"http://mikasa.github.io/tags/HDFS/"},{"name":"云计算","slug":"云计算","permalink":"http://mikasa.github.io/tags/云计算/"}],"keywords":[{"name":"分布式计算","slug":"分布式计算","permalink":"http://mikasa.github.io/categories/分布式计算/"}]},{"title":"stl set和map应用记录","slug":"stl-set鍜宮ap搴旂敤璁板綍","date":"2014-10-21T19:52:45.000Z","updated":"2016-11-24T07:16:14.306Z","comments":true,"path":"2014/10/22/stl-set鍜宮ap搴旂敤璁板綍/","link":"","permalink":"http://mikasa.github.io/2014/10/22/stl-set鍜宮ap搴旂敤璁板綍/","excerpt":"无聊水题，发现map容器使用的一块儿知识欠缺，就是很水的用map进行计数，赶紧补上。","text":"无聊水题，发现map容器使用的一块儿知识欠缺，就是很水的用map进行计数，赶紧补上。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;int,int&gt; s; int n; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; s.clear(); while(n--) &#123; int x; scanf(&quot;%d&quot;,&amp;x); s[x]++; &#125; map&lt;int,int&gt;::iterator i; for(i=s.begin();i!=s.end();i++) &#123; cout&lt;&lt;i-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;i-&gt;second&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}],"tags":[{"name":"stl","slug":"stl","permalink":"http://mikasa.github.io/tags/stl/"},{"name":"map","slug":"map","permalink":"http://mikasa.github.io/tags/map/"}],"keywords":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}]},{"title":"2014ACM-ICPC 地区赛鞍山站小结","slug":"2014ACM-ICPC-鍦板尯璧涢瀺灞辩珯灏忕粨","date":"2014-10-21T00:05:45.000Z","updated":"2016-11-24T07:16:13.822Z","comments":true,"path":"2014/10/21/2014ACM-ICPC-鍦板尯璧涢瀺灞辩珯灏忕粨/","link":"","permalink":"http://mikasa.github.io/2014/10/21/2014ACM-ICPC-鍦板尯璧涢瀺灞辩珯灏忕粨/","excerpt":"第一次参加ACM地区赛，感受挺深，以下用流水帐的形式记录一下这次的经历。 从出发开始说起，学校给定的火车票，从南京到鞍山，23小时车程，早上5点从学校出发，也是不容易，上车后发现南航的就在隔壁，压力甚大。报道时没有教练在，都由我们自己处理，有一点印象比较深，当志愿者问我们来自什么学校时，回答“河海大学”让边上天津大学的教练惊讶了一番，不知是学校太不出名还是太弱的原因。。感慨ORZ。主办方辽宁科技大学很周到，一个队伍配了一个志愿者，从开始引导到结束，这点很好～XD。 第一天下午参加了热身赛，4道题目。一开始场地的交换机出问题了，不能交题不能看scoreboard，而且problem set三人只能有一份，我们只好每人一张开始切题。我开始看的是A题（不记得了），是要计算一个长度最大为28的全排列中符合条件（即任意一个数与前后两个数都互质）。出于范围比较小，全排列范围是28！，我想了一个搜索+剪枝方法，开始打代码，纪存和范仕良在看其他题。码完题测试下速度，发现当数据到达13的规模时时间超过1秒，果断放弃。这时候切出去看了一下scoreboard，发现好多人做出了D（不记得了），然后范仕良和我交流了一下思路，觉得可行，我花了2分钟打完代码，交了，1Y。随后看其他题，一道概率DP，实在太难找出递推公式，无奈放弃。时间过了2小时时看了一下scoreboad发现AC2道的队伍不超过10支，然后我们就开始很随意聊天了XD～比赛结束看了一下排名，97,铜牌最后一名，还是很不错的～","text":"第一次参加ACM地区赛，感受挺深，以下用流水帐的形式记录一下这次的经历。 从出发开始说起，学校给定的火车票，从南京到鞍山，23小时车程，早上5点从学校出发，也是不容易，上车后发现南航的就在隔壁，压力甚大。报道时没有教练在，都由我们自己处理，有一点印象比较深，当志愿者问我们来自什么学校时，回答“河海大学”让边上天津大学的教练惊讶了一番，不知是学校太不出名还是太弱的原因。。感慨ORZ。主办方辽宁科技大学很周到，一个队伍配了一个志愿者，从开始引导到结束，这点很好～XD。 第一天下午参加了热身赛，4道题目。一开始场地的交换机出问题了，不能交题不能看scoreboard，而且problem set三人只能有一份，我们只好每人一张开始切题。我开始看的是A题（不记得了），是要计算一个长度最大为28的全排列中符合条件（即任意一个数与前后两个数都互质）。出于范围比较小，全排列范围是28！，我想了一个搜索+剪枝方法，开始打代码，纪存和范仕良在看其他题。码完题测试下速度，发现当数据到达13的规模时时间超过1秒，果断放弃。这时候切出去看了一下scoreboard，发现好多人做出了D（不记得了），然后范仕良和我交流了一下思路，觉得可行，我花了2分钟打完代码，交了，1Y。随后看其他题，一道概率DP，实在太难找出递推公式，无奈放弃。时间过了2小时时看了一下scoreboad发现AC2道的队伍不超过10支，然后我们就开始很随意聊天了XD～比赛结束看了一下排名，97,铜牌最后一名，还是很不错的～ 吃完晚饭，闲着无聊我们队3人跑到附近的网吧休闲一番～发现有队伍居然在网吧打BC。。给大神跪了OTZ～ 第二天早上正赛，赛前有点紧张，比赛时发现更紧张。开始时我切的是C，纪存看I，范仕良看的K（不记得了）。3分钟左右看一下排名，I有人出了，立马转战I，了解题意后还是由我主打代码，打完后稍微检查一番决定交，结果WA，当时就蒙了，再次审查一遍，认为是sqrt中double的问题，修改再交，依然WA。当时真是整个情绪有点崩溃，毕竟这只是道签到题。再次审查，把该改的地方再完善，依然WA。最后发现错误错在一个平时都不注意的地方。大概是： double dis = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) 其中x1,x2,y1,y2都是1e5的范围，当时我们一直觉得这样赋&#20540;，计算后的结果范围1e10肯定不会超double，但是居然是这儿出错了，原因是该语句先计算结果后转换精度，而结果爆int了。修改后AC，这时候看一下排行，120+，有些崩溃。 转战E题，我认为这题只要弄清楚各个情况即可，于是我开始打代码，写完发现测试数据都过不了。这时范仕良已经整理思路，换他来写了一个DP，1Y。 这时我们看了下排行，110+，而3题的大概只有30队。迅速看完D题，讨论，想出思路时大概50支队伍3题，赛后发现如果这时候1Y很有希望拿铜。 E题题意大概是有n个点，去掉k个点使得剩下的点方差最小。 一开始范仕良的思路是：最后得到的一定是个连续的区间，所以枚举各个长度为n-k的区间即可，但是被我和纪存否定了，原因是我们认为对于每次枚举要重新计算方差，整体复杂度为o(n*k)，会超时。之后纪存想出了一个方法，每次删去离重心最远的点，更新重心，复杂度o(n)，讨论后我们都觉得此方法可行，由我打代码，打完交后WA，再次找错误，改精度，依然WA，最后卡题到结束。没能拿到牌都挺郁闷。 返程的火车上和南理工的同学讨论了下，他们指出了错误。当一堆数据中有一部分密集无效数据和有效数据距离太远时，我们的算法结果是删后的数据重心在有效和无效数据之间，而正确的结果应该是删除无效的数据。之后我随机生成数据进行测试，发现错误所在。 以下为我们的错误代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;double p[50005];using namespace std;int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; memset(p,0,sizeof(p)); int n,k; cin&gt;&gt;n&gt;&gt;k; double sum = 0; for(int i = 1;i&lt;=n;i++) &#123; cin&gt;&gt;p[i]; sum+= p[i]; &#125; sort(p+1,p+n+1); double avp = sum/(double)n; int fst = 1; int lst = n; for(int i = 0;i &lt; k; i++) &#123; double fstv = avp - p[fst]; double lstv = p[lst] - avp; cout &lt;&lt; p[fst]&lt;&lt;\" : \"&lt;&lt;fstv &lt;&lt; \" \"&lt;&lt;p[lst]&lt;&lt;\" : \"&lt;&lt;lstv&lt;&lt;endl; if(fstv &gt; lstv) &#123; sum -= p[fst]; fst ++; avp = sum/(double)(n-i-1); &#125;else&#123; sum -= p[lst]; lst --; avp = sum/(double)(n-i-1); &#125; &#125; double ans = 0; for(int i=fst;i&lt;=lst;i++) &#123; cout&lt;&lt;p[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(int i=fst;i&lt;=lst;i++) &#123; ans += (p[i] - avp)*(p[i] - avp); &#125; printf(\"%.10f\\n\",ans); &#125; return 0;&#125; 当该算法碰到如下数据时： 1 13 4 1 1 1 1 5 6 7 8 9 10 11 12 13 会将10 11 12 13删除得道错误答案90 而正确答案则是删去4个1得到60. 再次思考原范仕良的思路是对的，只要事先处理一下方差公式: (xi - x平均)^2 = xi^2 + x平均^2 - 2xix平均 所以方差 = ∑xi^2 + nx平均 - 2∑xi*x平均 事先计算∑xi^2和∑xi，便可以以o(n)扫一遍得出结果。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; double p[50005]; using namespace std; int main() &#123; int T; cin&gt;&gt;T; while(T--) &#123; memset(p,0,sizeof(p)); int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i = 1;i&lt;=n;i++) cin&gt;&gt;p[i]; if(n==k) &#123; printf(\"%.9f\\n\",0); continue; &#125; sort(p+1,p+n+1); double sum = 0; double sqrsum = 0; for(int i = 1;i&lt;=n-k;i++) &#123; sum += p[i]; sqrsum += p[i] * p[i]; &#125; double avg = sum/(double) (n-k); double min = sqrsum + (n-k)*avg*avg - 2*sum*avg; // cout&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;sqrsum&lt;&lt;\" \"&lt;&lt;avg&lt;&lt;\" \"&lt;&lt;min&lt;&lt;endl; int flag = 0; for(int i = 1 ;i &lt;= k; i++) &#123; sum = sum + p[n-k+i] - p[i]; sqrsum = sqrsum + p[n-k+i]*p[n-k+i] - p[i]*p[i]; avg = sum/(double) (n-k); double now = sqrsum + (n-k)*avg*avg - 2*sum*avg; // cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;sum&lt;&lt;\" \"&lt;&lt;sqrsum&lt;&lt;\" \"&lt;&lt;avg&lt;&lt;\" \"&lt;&lt;min&lt;&lt;endl; if(now &lt; min) &#123; min = now; flag = i; &#125; &#125; printf(\"%.10f\\n\",min); &#125; &#125; 鞍山赛区失利，不过没有关系，西安争取拿牌～ 最后感谢一下比赛期间一直引导我们的志愿者粘微微（姓很奇怪XD～） 文章流水帐，无所谓啦～","categories":[{"name":"竞赛历程","slug":"竞赛历程","permalink":"http://mikasa.github.io/categories/竞赛历程/"}],"tags":[{"name":"ACM现场赛","slug":"ACM现场赛","permalink":"http://mikasa.github.io/tags/ACM现场赛/"}],"keywords":[{"name":"竞赛历程","slug":"竞赛历程","permalink":"http://mikasa.github.io/categories/竞赛历程/"}]},{"title":"hdu 2080 夹角有多大II","slug":"hdu-2080-澶硅鏈夊澶I","date":"2014-10-14T20:38:35.000Z","updated":"2016-11-24T07:16:14.196Z","comments":true,"path":"2014/10/15/hdu-2080-澶硅鏈夊澶I/","link":"","permalink":"http://mikasa.github.io/2014/10/15/hdu-2080-澶硅鏈夊澶I/","excerpt":"这是一题水题，至于为什么放在这儿。。因为要借鉴一下做法。。 地区赛的时候一道题之中要用到该题的结论，当时的做法是算(x轴-该点与原点连线)，再求其arctan算出角度，取两个角度求差。 这种做法的弊端就是，如果角度大于90度，大于180度，大于270度，得做相应处理，同时如果某点在坐标轴上也得处理，非常的繁琐。 今天做到这道水题才发现问题所在，原来直接用余弦定理一步搞定，cosA = (a^2 + b^2 - c^2)/(2ab)，同时也不用处理180度的问题。以后就不会犯这种错了。 需要提的一点是，x,y都是double，没发现这点用int，WA了数次。。不够细心","text":"这是一题水题，至于为什么放在这儿。。因为要借鉴一下做法。。 地区赛的时候一道题之中要用到该题的结论，当时的做法是算(x轴-该点与原点连线)，再求其arctan算出角度，取两个角度求差。 这种做法的弊端就是，如果角度大于90度，大于180度，大于270度，得做相应处理，同时如果某点在坐标轴上也得处理，非常的繁琐。 今天做到这道水题才发现问题所在，原来直接用余弦定理一步搞定，cosA = (a^2 + b^2 - c^2)/(2ab)，同时也不用处理180度的问题。以后就不会犯这种错了。 需要提的一点是，x,y都是double，没发现这点用int，WA了数次。。不够细心 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)#define WE freopen(\"out.txt\",\"w\",stdout) #define PI 3.141592654int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; double x1,x2,y1,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; double a=(double)sqrt((double)(x1*x1+y1*y1)); double b=(double)sqrt((double)(x2*x2+y2*y2)); double c=(double)sqrt((double)((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))); double arc=acos((a*a+b*b-c*c)/(2*a*b)); arc=arc*180/PI; printf(\"%.2f\\n\",arc); &#125;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"hdu","slug":"hdu","permalink":"http://mikasa.github.io/tags/hdu/"},{"name":"几何","slug":"几何","permalink":"http://mikasa.github.io/tags/几何/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"hdu 3076 ssworld VS DDD 概率dp","slug":"hdu-3076-ssworld-VS-DDD-姒傜巼dp","date":"2014-10-14T10:24:35.000Z","updated":"2016-11-24T07:16:14.212Z","comments":true,"path":"2014/10/14/hdu-3076-ssworld-VS-DDD-姒傜巼dp/","link":"","permalink":"http://mikasa.github.io/2014/10/14/hdu-3076-ssworld-VS-DDD-姒傜巼dp/","excerpt":"题意应该很明显，甩骰子决定谁扣血，输的扣血，赢的不变，平局双方都不变。 解题时有好几个地方想错了： 原本以为dp[i][j]表示当前A和B的血量，结果想反了，整个思路貌似有点偏 以为平局的概率也要加入，事实上也是错误1引起的，修改为dp[i][j]表示A和B赢的次数就好理解了，简化问题，去掉平局，p1 = win/(win+lose) ; p2 = lose/(win+lose) 最后的答案不是dp数组中的一个，而是A赢了hp2次的概率，就是dp[hp2-1][j(j从0到hp1-1求和)]*win 解决了这几个问题，结果提交还是WA，后来看了discuss才发现数据错了，两人血量反了，所以把其中的i和j互换。","text":"题意应该很明显，甩骰子决定谁扣血，输的扣血，赢的不变，平局双方都不变。 解题时有好几个地方想错了： 原本以为dp[i][j]表示当前A和B的血量，结果想反了，整个思路貌似有点偏 以为平局的概率也要加入，事实上也是错误1引起的，修改为dp[i][j]表示A和B赢的次数就好理解了，简化问题，去掉平局，p1 = win/(win+lose) ; p2 = lose/(win+lose) 最后的答案不是dp数组中的一个，而是A赢了hp2次的概率，就是dp[hp2-1][j(j从0到hp1-1求和)]*win 解决了这几个问题，结果提交还是WA，后来看了discuss才发现数据错了，两人血量反了，所以把其中的i和j互换。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;ctime&gt; using namespace std; #define LL long long #define ULL unsigned long long //#define mod 1000000007 #define eps 1e-8 #define MP make_pair #define REP(i,a,b) for(int i = a; i &lt; b; ++i) #define RREP(i,a,b) for(int i = b; i &gt; a ; --i) #define RE freopen(\"in.txt\",\"r\",stdin) #define WE freopen(\"out.txt\",\"w\",stdout) #define N 2001 double a[7],b[7]; double dp[N][N]; //dp[i][j]表示A赢了i局，B赢了j局，最后求A赢了hp2局的概率 int main() &#123; RE; int hp1,hp2; while(cin&gt;&gt;hp1&gt;&gt;hp2) &#123; memset(dp,0,sizeof(dp)); double win,lose,draw; win = lose = draw = 0; for(int i=1;i&lt;=6;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=6;i++) cin&gt;&gt;b[i]; for(int i=2;i&lt;=6;i++) for(int j=1;j&lt;i;j++) win += a[i]*b[j]; for(int i=1;i&lt;=5;i++) for(int j=i+1;j&lt;=6;j++) lose += a[i]*b[j]; draw = 1-win-lose; double win_p = (win)/(1-draw); double lose_p = lose/(1-draw); dp[0][0] = 1; for(int j=0;j&lt;=hp1-1;j++) for(int i=0;i&lt;=hp2;i++) &#123; if(i+j&gt;0) &#123; if(i&gt;0) dp[i][j] += dp[i-1][j]*lose_p; if(j&gt;0) dp[i][j] += dp[i][j-1]*win_p; &#125; &#125; //cout&lt;&lt;dp[hp2-1][hp1-1]&lt;&lt;endl; double ans = 0; for(int i=0;i&lt;=hp2-1;i++) ans += dp[i][hp1-1] * win_p; if(ans&gt;1) ans=1; printf(\"%.6f\\n\",ans); &#125; &#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"概率dp","slug":"概率dp","permalink":"http://mikasa.github.io/tags/概率dp/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"CodeForces 148D Bags of mice 概率dp","slug":"CodeForces-148D-Bags-of-mice-姒傜巼dp","date":"2014-10-14T09:47:35.000Z","updated":"2016-11-24T07:16:13.916Z","comments":true,"path":"2014/10/14/CodeForces-148D-Bags-of-mice-姒傜巼dp/","link":"","permalink":"http://mikasa.github.io/2014/10/14/CodeForces-148D-Bags-of-mice-姒傜巼dp/","excerpt":"开始看概率dp的内容，碰到算期望的题目，一般就要用概率dp了。这是道入门的概率dp，弄清楚每一步发生的事件和对应的概率，求出递推公式就OK了。123dp[i][j][0]表示轮到公主取，还剩下i只白鼠，j只黑鼠；dp[i][j][1]表示轮到龙取，还剩下i只白鼠，j只黑鼠； 获胜的期望就是dp[w][b][0]。1234567dp[i][j][0] = p1 //公主抽到的是白鼠概率p1，结束dp[i][j][0] += dp[i][j-1][1] * p2 //公主抽到的是黑鼠概率p2dp[i][j][1] += dp[i-1][j-1][0] * p3 // 龙抽到的是黑鼠，吓跑一只白鼠概率p3dp[i][j][1] += dp[i][j-2][0] * p4 //龙抽到黑鼠，吓跑一只黑鼠概率p4 再依次算概率 就OK了。","text":"开始看概率dp的内容，碰到算期望的题目，一般就要用概率dp了。这是道入门的概率dp，弄清楚每一步发生的事件和对应的概率，求出递推公式就OK了。123dp[i][j][0]表示轮到公主取，还剩下i只白鼠，j只黑鼠；dp[i][j][1]表示轮到龙取，还剩下i只白鼠，j只黑鼠； 获胜的期望就是dp[w][b][0]。1234567dp[i][j][0] = p1 //公主抽到的是白鼠概率p1，结束dp[i][j][0] += dp[i][j-1][1] * p2 //公主抽到的是黑鼠概率p2dp[i][j][1] += dp[i-1][j-1][0] * p3 // 龙抽到的是黑鼠，吓跑一只白鼠概率p3dp[i][j][1] += dp[i][j-2][0] * p4 //龙抽到黑鼠，吓跑一只黑鼠概率p4 再依次算概率 就OK了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define LL long long#define ULL unsigned long long//#define mod 1000000007#define eps 1e-8#define MP make_pair#define REP(i,a,b) for(int i = a; i &lt; b; ++i)#define RREP(i,a,b) for(int i = b; i &gt; a ; --i)#define RE freopen(\"in.txt\",\"r\",stdin)#define WE freopen(\"out.txt\",\"w\",stdout) #define N 1005double dp[N][N][2]; int main()&#123; int w,b; cin&gt;&gt;w&gt;&gt;b; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;=w;i++) for(int j=0;j&lt;=b;j++) &#123; if(i&gt;0) dp[i][j][0] = i/(double)(i+j); if(j&gt;0) dp[i][j][0] += j/(double)(i+j) * dp[i][j-1][1] ; if(i&gt;=1&amp;&amp;j&gt;=1) dp[i][j][1] += j/(double)(i+j) *i/(double)(i+j-1) * dp[i-1][j-1][0] ; if(j&gt;=2) dp[i][j][1] += j/(double)(i+j) * (j-1)/(double)(i+j-1) * dp[i][j-2][0] ; &#125; printf(\"%.9lf\\n\",dp[w][b][0]);&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"CodeForces","slug":"CodeForces","permalink":"http://mikasa.github.io/tags/CodeForces/"},{"name":"概率dp","slug":"概率dp","permalink":"http://mikasa.github.io/tags/概率dp/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"遗传算法求x^2+y^2的最大值，C++实现","slug":"閬椾紶绠楁硶姹倄-2-y-2鐨勬渶澶у€硷紝C-瀹炵幇","date":"2014-10-08T04:51:43.000Z","updated":"2016-11-24T07:16:14.540Z","comments":true,"path":"2014/10/08/閬椾紶绠楁硶姹倄-2-y-2鐨勬渶澶у€硷紝C-瀹炵幇/","link":"","permalink":"http://mikasa.github.io/2014/10/08/閬椾紶绠楁硶姹倄-2-y-2鐨勬渶澶у€硷紝C-瀹炵幇/","excerpt":"最近和学院的教授开始学习数据挖掘和机器学习的课程，第一步就是学习简单的遗传算法。 在网上找了篇教程，于是将其实现。文章地址非常好的理解遗传算法的例子。 内容是求求f(x1,x2)=x1^2+x2^2的最大值 ，x1∈{1,2,3,4,5,6,7} , x2∈{1,2,3,4,5,6,7} 。 选择样本数量为8，经过100代的迭代，效果还不错","text":"最近和学院的教授开始学习数据挖掘和机器学习的课程，第一步就是学习简单的遗传算法。 在网上找了篇教程，于是将其实现。文章地址非常好的理解遗传算法的例子。 内容是求求f(x1,x2)=x1^2+x2^2的最大值 ，x1∈{1,2,3,4,5,6,7} , x2∈{1,2,3,4,5,6,7} 。 选择样本数量为8，经过100代的迭代，效果还不错 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271/*** 遗传算法求f(x1,x2)=x1^2+x2^2的最大值 ** x1∈&#123;1,2,3,4,5,6,7&#125; , x2∈&#123;1,2,3,4,5,6,7&#125; ** @Jet-Muffin*/ #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;ctime&gt;using namespace std;#define SAMPLE_NUM 8 //样本数量 #define EVOLVE_NUM 300 //进化代数 #define random(x) (rand()%x) //随机函数 #define VARIATE_RATE 10 //变异率 void init();void output();void cross();void cross_change(int a,int b);//样本node struct node&#123; int bin[6]; int x1,x2; int f; double pct;&#125;group[SAMPLE_NUM];//样本集合group node temp[SAMPLE_NUM]; //操作中间变量数组 int choosen[SAMPLE_NUM]; //概率分布区域数组 //初始化，随机生成样本 void init() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; //随机生成bin数组 for(int j = 0; j &lt; 6; j++) &#123; int pct = random(100); if(pct &gt;= 50) group[i].bin[j] = 1; else group[i].bin[j] = 0; &#125; &#125;&#125;//计算相应数值 void calcu() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; //生成相应x1、x2 int base = 1; group[i].x1 = group[i].x2 = 0; for(int j = 6 / 2 - 1; j &gt;= 0; j--) &#123; group[i].x1 += base * group[i].bin[j]; base *= 2; &#125; base = 1; for(int j = 6 - 1; j &gt;= 6 / 2; j--) &#123; group[i].x2 += base * group[i].bin[j]; base *= 2; &#125; //计算相应适值 group[i].f = group[i].x1 * group[i].x1 + group[i].x2 * group[i].x2; //计算占总数百分比 int totf = 0; for(int i = 0; i &lt; SAMPLE_NUM; i++) totf += group[i].f; for(int i = 0; i &lt; SAMPLE_NUM; i++) group[i].pct = group[i].f / (double)totf; &#125;&#125;//选择过程 void choose() &#123; cout&lt;&lt;endl; cout&lt;&lt;\"Choosen:.......\"&lt;&lt;endl; memset(choosen,0,sizeof(choosen)); //计算概率区域 choosen[0] = floor(group[0].pct * 100 + 0.5); for(int i = 1; i &lt; SAMPLE_NUM - 1; i++) &#123; choosen[i] = choosen[i-1] + floor(group[i].pct * 100 + 0.5); &#125; choosen[SAMPLE_NUM - 1] = 100; cout&lt;&lt;\"Posibility Area: \"; for(int i = 0; i &lt; SAMPLE_NUM; i++) cout&lt;&lt;choosen[i]&lt;&lt;\" \"; cout&lt;&lt;endl; //生成随机数以模拟选择 for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; int pct = random(100); int choosen_node; for(int j = 1; j &lt; SAMPLE_NUM; j++) if(pct &lt; choosen[j]) &#123; choosen_node = j; break; &#125; cout&lt;&lt;\"seed:\"&lt;&lt;pct&lt;&lt;\", \"; cout&lt;&lt;\"node \"&lt;&lt;choosen_node + 1&lt;&lt;\" was choosen\"&lt;&lt;endl; temp[i] = group[choosen_node]; &#125; //输出选择结果 cout&lt;&lt;\"choosen result:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;temp[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125;&#125;//交叉运算 void cross() &#123; cout&lt;&lt;endl; cout&lt;&lt;\"Crossing:....\"&lt;&lt;endl; cout&lt;&lt;\"Matching:...\"&lt;&lt;endl; //用vector的random_shuffle实现随机乱序配对，从vector中取两个node就进行运算，实现随机交叉 vector&lt;int&gt; seeds; for (int i = 0; i &lt; SAMPLE_NUM; i++) seeds.push_back(i + 1); random_shuffle(seeds.begin(), seeds.end()); int cnt = 0; int pair_fst,pair_sec; for(vector&lt;int&gt;::iterator it = seeds.begin(); it != seeds.end(); it++) &#123; cnt++; if(cnt&amp;1) pair_fst = *it; else pair_sec = *it; if(cnt == 2) &#123; cout&lt;&lt;\"Matching result: \"&lt;&lt;pair_fst&lt;&lt;\"-\"&lt;&lt;pair_sec&lt;&lt;endl; cnt = 0; cross_change(pair_fst - 1,pair_sec - 1); &#125; &#125; //输出交换结果 cout&lt;&lt;\"cross result:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;temp[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125;//交叉运算过程 void cross_change(int a,int b) &#123; //生成交叉点 int cross_seed = random(4) + 1; cout&lt;&lt;\"cross position:\"&lt;&lt;cross_seed&lt;&lt;endl; //输出交换前串信息 cout&lt;&lt;\"temp[\"&lt;&lt;a + 1&lt;&lt;\"]: \"; for(int i = 0; i &lt; 6; i++) &#123; if(i == cross_seed) cout&lt;&lt;\"| \"; cout&lt;&lt;temp[a].bin[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; cout&lt;&lt;\"temp[\"&lt;&lt;b + 1&lt;&lt;\"]: \"; for(int i = 0; i &lt; 6; i++) &#123; if(i == cross_seed) cout&lt;&lt;\"| \"; cout&lt;&lt;temp[b].bin[i]&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; //进行交换 for(int i = cross_seed; i &lt; 6; i++) &#123; int tmp; tmp = temp[a].bin[i]; temp[a].bin[i] = temp[b].bin[i]; temp[b].bin[i] = tmp; &#125;&#125; //变异运算 void variation() &#123; cout&lt;&lt;\"Variation:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i&lt;&lt;\"]:\" ; int position_seed = random(5); cout&lt;&lt;\"variate pos: \"&lt;&lt;position_seed&lt;&lt;\",\"; int var_seed = random(100); if(var_seed &lt; VARIATE_RATE) &#123; cout&lt;&lt;\" success\"; if(temp[i].bin[position_seed]) temp[i].bin[position_seed] = 0; else temp[i].bin[position_seed] = 1; &#125; cout&lt;&lt;endl; &#125; //输出变异结果 cout&lt;&lt;\"variate result:\"&lt;&lt;endl; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"temp[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;temp[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;//将运算的temp数组赋值给group数组以方便下一次迭代运算 void trans() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) group[i] = temp[i];&#125;//输出信息 void output() &#123; for(int i = 0; i &lt; SAMPLE_NUM; i++) &#123; cout&lt;&lt;\"node[\"&lt;&lt;i + 1&lt;&lt;\"]: \"; for(int j = 0; j &lt; 6; j++) cout&lt;&lt;group[i].bin[j]&lt;&lt;\" \"; cout&lt;&lt;\" x1: \"&lt;&lt;group[i].x1; cout&lt;&lt;\" x2: \"&lt;&lt;group[i].x2; cout&lt;&lt;\" f: \"&lt;&lt;group[i].f; cout&lt;&lt;\" percent:\"&lt;&lt;group[i].pct&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125; //总函数接口 void evolution() &#123; init(); calcu(); output(); for(int i = 0; i &lt; EVOLVE_NUM; i++) &#123; choose(); cross(); variation(); trans(); calcu(); output(); &#125;&#125;int main() &#123; srand((int)time(0)); evolution();&#125; 结果：该函数最大值为98，有7个样本进化到了该数值，还有1个样本为次大值，效果不错。","categories":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}],"tags":[{"name":"遗传算法","slug":"遗传算法","permalink":"http://mikasa.github.io/tags/遗传算法/"}],"keywords":[{"name":"算法分析","slug":"算法分析","permalink":"http://mikasa.github.io/categories/算法分析/"}]},{"title":"算m点问题，深搜解决","slug":"绠梞鐐归棶棰橈紝娣辨悳瑙ｅ喅","date":"2014-10-08T04:49:28.000Z","updated":"2016-11-24T07:16:14.477Z","comments":true,"path":"2014/10/08/绠梞鐐归棶棰橈紝娣辨悳瑙ｅ喅/","link":"","permalink":"http://mikasa.github.io/2014/10/08/绠梞鐐归棶棰橈紝娣辨悳瑙ｅ喅/","excerpt":"算法导论课后的一道题。 题目：给定k个正整数，用算数运算符+,-,*,/将这k个正整数链接起来，使最终的得数恰为m。 样例输入： 5 125 7 2 2 12 3 样例输出： 7 3 = 21; 21 12 = 252 ; 252 - 2 = 250; 250 / 2 = 125 简单的用深搜解决了，不考虑优化什么的了，数据多的话会超时，不过这不是A题就这样吧~XD","text":"算法导论课后的一道题。 题目：给定k个正整数，用算数运算符+,-,*,/将这k个正整数链接起来，使最终的得数恰为m。 样例输入： 5 125 7 2 2 12 3 样例输出： 7 3 = 21; 21 12 = 252 ; 252 - 2 = 250; 250 / 2 = 125 简单的用深搜解决了，不考虑优化什么的了，数据多的话会超时，不过这不是A题就这样吧~XD 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;ctime&gt; using namespace std; #define maxn 100 int data[maxn],vis[maxn],num[maxn]; char op[maxn]; int n,m; int value = 0; int flag = 0; void output() &#123; int tmp = num[0]; for(int i = 1; i &lt; n ; i++) &#123; cout&lt;&lt;tmp&lt;&lt;\" \"; if(op[i] == '+') &#123; cout&lt;&lt;\"+\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp += num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; if(op[i] == '-') &#123; cout&lt;&lt;\"-\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp -= num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; if(op[i] == '*') &#123; cout&lt;&lt;\"*\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp *= num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; if(op[i] == '/') &#123; cout&lt;&lt;\"/\"&lt;&lt;\" \"; cout&lt;&lt;num[i]&lt;&lt;\" = \"; tmp /= num[i]; cout&lt;&lt;tmp&lt;&lt;\";\"; &#125; &#125; &#125; void dfs(int t) &#123; //cout&lt;&lt;t&lt;&lt;\" \"&lt;&lt;value&lt;&lt;\" \"&lt;&lt;endl; if(t &gt;= n) &#123; if(value == m) &#123; cout&lt;&lt;\"found!\"&lt;&lt;endl; output(); flag = 1; &#125; &#125; else &#123; for(int i = 0; i &lt; n ; i++) &#123; if(t == 0) &#123; if(!vis[i]) &#123; value = data[i]; num[t] = data[i]; vis[i] = 1; dfs(t + 1); vis[i] = 0; &#125; &#125; else &#123; if(!vis[i]) &#123; vis[i] = 1; int tmp = value; op[t] = '+'; num[t] = data[i]; value = tmp + data[i]; dfs(t + 1); if(flag) return; op[t] = '-'; num[t] = data[i]; value = tmp - data[i]; dfs(t + 1); if(flag) return; op[t] = '*'; num[t] = data[i]; value = tmp * data[i]; dfs(t + 1); if(flag) return ; if(data[i] != 0) &#123; op[t] = '/'; num[t] = data[i]; value = tmp / data[i]; dfs(t + 1); if(flag) return; &#125; value = tmp; vis[i] = 0; &#125; &#125; &#125; &#125; &#125; int main() &#123; // freopen(\"in\",\"r\",stdin); cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt; n; i++) cin&gt;&gt;data[i]; memset(vis, 0, sizeof(vis)); memset(num, 0, sizeof(num)); memset(op, 0, sizeof(op)); dfs(0); if(!flag) cout&lt;&lt;\"not found!\"&lt;&lt;endl;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"dfs","slug":"dfs","permalink":"http://mikasa.github.io/tags/dfs/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"2014 Multi-University Training Contest 2 1011 ZCC Loves Codefires 解题报告","slug":"2014-Multi-University-Training-Contest-2-1011-ZCC-Loves-Codefires-瑙ｉ鎶ュ憡","date":"2014-07-24T03:06:19.000Z","updated":"2016-11-24T07:16:13.806Z","comments":true,"path":"2014/07/24/2014-Multi-University-Training-Contest-2-1011-ZCC-Loves-Codefires-瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2014/07/24/2014-Multi-University-Training-Contest-2-1011-ZCC-Loves-Codefires-瑙ｉ鎶ュ憡/","excerpt":"暑期联训第二场。 高中被镇海虐了3年，大学继续被镇海虐，刚入ACM这条路不久，基础不够扎实，镇海还出这么变态的题目= =，就AC了最后一题。。 题目如上，总结就是类似分顺序取数，每个数大小不同，但是取出顺序会累加从而影响最后的结果，为了使最后结果最小，要找到最优解。 第一下看到这个题目，第一反应就是用动态规划去做，但是琢磨半天很难想出状态方程，因为它每个状态点无法比较状态对应的值大小（即使比较了也无意义）。 多次尝试之后，开始寻求其他方法，想了一种最朴素的方法，","text":"暑期联训第二场。 高中被镇海虐了3年，大学继续被镇海虐，刚入ACM这条路不久，基础不够扎实，镇海还出这么变态的题目= =，就AC了最后一题。。 题目如上，总结就是类似分顺序取数，每个数大小不同，但是取出顺序会累加从而影响最后的结果，为了使最后结果最小，要找到最优解。 第一下看到这个题目，第一反应就是用动态规划去做，但是琢磨半天很难想出状态方程，因为它每个状态点无法比较状态对应的值大小（即使比较了也无意义）。 多次尝试之后，开始寻求其他方法，想了一种最朴素的方法， 定义结构体1234567point&#123; int E; int K; &#125; 先用快速排序将按分值将point从大到小排序，然后依次从大到小进行冒泡，每次冒泡能保证前几次会使函数值减小，当再冒泡函数值增加时就停止该数的冒泡，换第二大的数进行冒泡。但是该算法每进行一次冒泡需要计算一次函数值，且n过大，最后导致TLE。 之后开始寻找变换的规律， 写出一组数据： 10 10 20 30 1 2 3 4 totEi 30 50 60 70 Ki 4 3 2 1 交换3 和 4 后得到 totEi 20 50 60 70 Ki 3 4 2 1 可以看出，3和4的交换，对于其他项是不会有影响的，对值的影响来源于304+503与203+504的大小变换。 用常规变量表示的话就是，point(i)&gt;point(i+1) 的充要条件是 Ei+1Ki+1+(Ei+Ei+1)Ki&lt;EiKi+(Ei+1+Ei)Ki+1 化简得 EiKi+1&lt;Ei+1Ki 即Ei/Ki &gt; Ei+1/Ki+1 所以只要该条件满足，交换point(i)与point(i+1）就能得到最优解。 因而在point结构体中加入变量double s // s=E/K; 根据s对 point进行快速排序，排序得到的就是最优解，求和就是要出的结果了。 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;algorithm&gt;using namespace std;struct point&#123; int E; int K; double s;&#125;;struct point p[100001]; int cmp(point p1,point p2) &#123; return p1.s&lt;p2.s;&#125;int main() &#123; freopen(\"in.txt\",\"r\",stdin); int i,j,N; int min; __int64 sum=0; __int64 totE=0; cin&gt;&gt;N; for(i=1;i&lt;=N;i++) cin&gt;&gt;p[i].E; for(i=1;i&lt;=N;i++) cin&gt;&gt;p[i].K; for(i=1;i&lt;=N;i++) p[i].s = p[i].E/(double)p[i].K; sort(p+1,p+N+1,cmp); for(i=1;i&lt;=N;i++) &#123; totE+=p[i].E; sum+= totE*p[i].K; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"http://mikasa.github.io/tags/dp/"},{"name":"多校联训","slug":"多校联训","permalink":"http://mikasa.github.io/tags/多校联训/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]},{"title":"hdu4828 Grids 百度之星初赛1002解题报告","slug":"hdu4828-Grids-鐧惧害涔嬫槦鍒濊禌1002瑙ｉ鎶ュ憡","date":"2014-07-21T03:09:36.000Z","updated":"2016-11-24T07:16:14.306Z","comments":true,"path":"2014/07/21/hdu4828-Grids-鐧惧害涔嬫槦鍒濊禌1002瑙ｉ鎶ュ憡/","link":"","permalink":"http://mikasa.github.io/2014/07/21/hdu4828-Grids-鐧惧害涔嬫槦鍒濊禌1002瑙ｉ鎶ュ憡/","excerpt":"搞ACM起步比较晚，但是对这方面兴趣很大，第一次参加百度之星，资格赛水过一道题进入初赛，结果初赛被一道题难倒了。 初赛分两场，每场筛选500人（赛程规定），而之后的结果上看，只有约250人A出题，而大多数人都是通过这道题拿到复赛入场券。这道题我一直觉得非常接近结果了，但是在最重要的环节，也就是取模上出了很大的问题，导致没有A出该题，下面是该题的分析。 题干上，大多数人可以看出看出规律，即求卡特兰数，HDOJ上有相类似的题目，但是这道题的数据量非常大，有100万之多，因而题目上要求对1000000007取模。 卡特兰数有很多递推公式，我选择的是h(n)=h(n-1)(4n-2)/(n+1);这条。 由于数据量比较大，因而我选择用打表的方式，但是这里出现了一个问题，卡特兰数的数据在不断的增大，因而一定要在取模的基础上进行递推，然而简单地进行取模会造成递推公式出错，即不能在原结果上直接取模。 比赛时就卡在这点上了，怎么想都想不出改进的方法。 直到后来做到HDOJ的拓展欧几里德的题目（HDOJ 1576），才直到这道题的解法。 除法的取模需要用extgcd的算法进行取逆，这是该题的关键。","text":"搞ACM起步比较晚，但是对这方面兴趣很大，第一次参加百度之星，资格赛水过一道题进入初赛，结果初赛被一道题难倒了。 初赛分两场，每场筛选500人（赛程规定），而之后的结果上看，只有约250人A出题，而大多数人都是通过这道题拿到复赛入场券。这道题我一直觉得非常接近结果了，但是在最重要的环节，也就是取模上出了很大的问题，导致没有A出该题，下面是该题的分析。 题干上，大多数人可以看出看出规律，即求卡特兰数，HDOJ上有相类似的题目，但是这道题的数据量非常大，有100万之多，因而题目上要求对1000000007取模。 卡特兰数有很多递推公式，我选择的是h(n)=h(n-1)(4n-2)/(n+1);这条。 由于数据量比较大，因而我选择用打表的方式，但是这里出现了一个问题，卡特兰数的数据在不断的增大，因而一定要在取模的基础上进行递推，然而简单地进行取模会造成递推公式出错，即不能在原结果上直接取模。 比赛时就卡在这点上了，怎么想都想不出改进的方法。 直到后来做到HDOJ的拓展欧几里德的题目（HDOJ 1576），才直到这道题的解法。 除法的取模需要用extgcd的算法进行取逆，这是该题的关键。 该题代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;__int64 h[1000001];const int MOD=1000000007;int extgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1; y=0; return a; &#125; int r=extgcd(b,a%b,x,y); int t=x; x=y; y=t-a/b*y; return r;&#125;int main()&#123; int T; int n,i,j,x,y; h[0]=1; for(i=1;i&lt;=1000000;i++) &#123; h[i]=(4*i-2)%MOD; h[i]=(h[i]*h[i-1])%MOD; extgcd(i+1,MOD,x,y); h[i]=(h[i]*(x+MOD)%MOD)%MOD; &#125; cin&gt;&gt;T; for(i=1;i&lt;=T;i++) &#123; cin&gt;&gt;n; cout&lt;&lt;\"Case #\"&lt;&lt;i&lt;&lt;\":\"&lt;&lt;endl; cout&lt;&lt;h[n]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://mikasa.github.io/tags/数论/"},{"name":"百度之星","slug":"百度之星","permalink":"http://mikasa.github.io/tags/百度之星/"}],"keywords":[{"name":"算法题解","slug":"算法题解","permalink":"http://mikasa.github.io/categories/算法题解/"}]}]}